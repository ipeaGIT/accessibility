% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/constrained_accessibility.R
\name{constrained_accessibility}
\alias{constrained_accessibility}
\title{Constrained accessibility}
\usage{
constrained_accessibility(
  constraint,
  travel_matrix,
  land_use_data,
  travel_cost,
  decay_function,
  demand,
  supply,
  return_demand_side = NULL,
  error_threshold = 0.001,
  improvement_threshold = 1e-06,
  max_iterations = 1000,
  group_by = character(0),
  fill_missing_ids = TRUE,
  detailed_results = FALSE
)
}
\arguments{
\item{constraint}{A string. One of \code{"total"}, \code{"singly"}, or \code{"doubly"}.}

\item{travel_matrix}{A data frame. The travel matrix describing the costs
(i.e. travel time, distance, monetary cost, etc.) between the origins and
destinations in the study area. Must contain the columns \code{from_id}, \code{to_id}
and any others specified in \code{travel_cost}.}

\item{land_use_data}{A data frame. The distribution of opportunities within
the study area cells. Must contain the columns \code{id} and any others
specified in \code{opportunity}.}

\item{travel_cost}{A string. The name of the column in \code{travel_matrix}
with the travel cost between origins and destinations.}

\item{decay_function}{A \code{fuction} that converts travel cost into an
impedance factor used to weight opportunities. This function should take a
\code{numeric} vector and also return a \code{numeric} vector as output, with the
same length as the input. For convenience, the package currently includes
the following functions: \code{\link[=decay_binary]{decay_binary()}}, \code{\link[=decay_exponential]{decay_exponential()}},
\code{\link[=decay_power]{decay_power()}} and \code{\link[=decay_stepped]{decay_stepped()}}. See the documentation of each decay
function for more details.}

\item{demand}{A string. The name of the column in \code{land_use_data} with the
number of opportunity-demanders at each origin (e.g., people) that will be
considered.}

\item{supply}{A string. The name of the column in \code{land_use_data} with the
number of opportunity supply at each destination (e.g., jobs, school-seats)
that will be considered.}

\item{return_demand_side}{Logical for \code{"total"} and \code{"singly"}, must be \code{NULL} for \code{"doubly"}.}

\item{error_threshold}{Numeric. Convergence criterion for doubly-constrained case.}

\item{improvement_threshold}{Numeric. Convergence criterion for improvement.}

\item{max_iterations}{Integer. Maximum iterations for doubly-constrained calibration.}

\item{group_by}{A \code{character} vector. When not \code{character(0)} (the default),
indicates the \code{travel_matrix} columns that should be used to group the
accessibility estimates by. For example, if \code{travel_matrix} includes a
departure time column, that specifies the departure time of each entry in
the data frame, passing \code{"departure_time"} to this parameter results in
accessibility estimates grouped by origin and by departure time.}

\item{fill_missing_ids}{A \code{logical}. When calculating grouped accessibility
estimates (i.e. when \code{by_col} is not \code{NULL}), some combinations of groups
and origins may be missing. For example, if a single trip can depart from
origin \code{A} at 7:15am and reach destination \code{B} within 55 minutes, but no
trips departing from \code{A} at 7:30am can be completed at all, this second
combination will not be included in the output. When \code{TRUE} (the default),
the function identifies which combinations would be left out and fills
their respective accessibility values with 0, which incurs in a
performance penalty.}

\item{detailed_results}{Logical. Whether to return detailed OD-level results.}
}
\description{
Calculates accessibility using constrained gravity models:
\itemize{
\item \code{"total"}: Allocates total opportunities proportionally based on travel impedance.
\item \code{"singly"}: Allocates opportunities proportionally, constrained on one side (demand or supply).
\item \code{"doubly"}: Allocates flows so origin totals equal demand and destination totals equal supply.
}

This function is generic over any kind of numeric travel cost,
such as distance, time and money.
}
\details{
See individual function documentation for mathematical details:
\code{\link[=total_constrained]{total_constrained()}}, \code{\link[=singly_constrained]{singly_constrained()}}, \code{\link[=doubly_constrained]{doubly_constrained()}}.
}
\examples{
# Load demo data shipped with the package (used for 'total' and 'singly')
data_dir <- system.file("extdata", package = "accessibility")
travel_matrix <- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data <- readRDS(file.path(data_dir, "land_use_data.rds"))

# Total-constrained (supply-side)
constrained_accessibility("total", travel_matrix, land_use_data,
  travel_cost     = "travel_time",
  decay_function  = decay_exponential(0.1),
  demand          = NULL,
  supply          = "jobs",
  return_demand_side = FALSE
)

# Singly-constrained (demand-side)
constrained_accessibility("singly", travel_matrix, land_use_data,
  travel_cost     = "travel_time",
  decay_function  = decay_exponential(0.1),
  demand          = "population",
  supply          = "jobs",
  return_demand_side = TRUE
)

# Doubly-constrained: use a small toy dataset with matching totals
tm_small <- data.table::data.table(
  expand.grid(from_id = c("1","2","3"), to_id = c("1","2","3"))
)
tm_small[, travel_time := c(10, 30, 15, 30, 10, 25, 15, 25, 10)]
lu_small <- data.table::data.table(
  id         = c("1","2","3"),
  population = c(4, 10, 6),   # sum = 20
  jobs       = c(7,  5,  8)   # sum = 20
)

constrained_accessibility("doubly", tm_small, lu_small,
  travel_cost     = "travel_time",
  decay_function  = decay_exponential(0.1),
  demand          = "population",
  supply          = "jobs",
  return_demand_side = NULL
)
}
\concept{Constrained accessibility}
