[{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Introduction to accessibility: calculating accessibility measures","text":"using accessibility please make sure installed computer. can download either stable version CRAN… …development version GitHub.","code":"install.packages(\"accessibility\") # install.packages(\"remotes\") remotes::install_github(\"ipeaGIT/accessibility\")"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"overview-of-the-package","dir":"Articles","previous_headings":"","what":"Overview of the package","title":"Introduction to accessibility: calculating accessibility measures","text":"time writing vignette, accessibility package includes five different functions calculate accessibility: cost_to_closest() - calculates minimum travel cost closest n number opportunities. cumulative_cutoff() - calculates frequently used threshold-based cumulative opportunities measure. cumulative_interval() - calculates accessibility median/mean (summary measure, really) number opportunities can reached within cost interval. gravity() - calculates gravity-based accessibility, taking decay function specified user (paragraphs). floating_catchment_area() - calculates accessibility taking account effects competition opportunities different floating catchment area measures. may noticed ’ve mentioned times functions calculate accessibility using travel cost, travel time. ’s ’re treating costs generic sense: anything increases impedance origin destination, travel time, monetary costs, distances, risk perception, etc., can considered generic cost. gravity() floating_catchment_area() functions can use different decay functions estimating accessibility levels. decay functions effectively weigh number opportunities destination factor depends travel cost origin destination. convenience, package currently includes following decay functions: decay_binary() - binary decay function (one used cumulative opportunities measures). decay_exponential() - negative exponential decay function. decay_linear() - linear decay function (weights decay linearly 1 0 specific travel cost cutoff reached). decay_power() - inverse power decay function. decay_stepped() - stepped decay function (similar decay_binary(), can take arbitrary number steps, instead single one). users can also specify custom decay functions, need use functions currently included package. details , please read decay functions vignette.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"demonstration-on-sample-data","dir":"Articles","previous_headings":"","what":"Demonstration on sample data","title":"Introduction to accessibility: calculating accessibility measures","text":"Enough talking. Let’s demonstrate key features package. First ’ll need load libraries ’ll using:","code":"library(accessibility) library(data.table) library(ggplot2) library(sf)"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"data-requirements","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Data requirements","title":"Introduction to accessibility: calculating accessibility measures","text":"use accessibility, need pre-computed travel cost matrix land use data (e.g. location jobs, healthcare, population, etc.). mentioned , travel costs can presented terms travel times, distances monetary costs, example. dataset must structured data.frame containing, least, columns from_id, to_id travel cost origin-destination pair. data look similar sample dataset public transport travel times city Belo Horizonte, Brazil, included package demonstration purposes1. land use data must also structured data.frame must contain id column, referring ids listed travel matrix, number opportunities/facilities/services spatial unit. sample dataset ’ll using looks like :","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\")  travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) head(travel_matrix) #>            from_id           to_id travel_time #>             <char>          <char>       <num> #> 1: 89a88cdb57bffff 89a88cdb57bffff         5.8 #> 2: 89a88cdb57bffff 89a88cdb597ffff        47.0 #> 3: 89a88cdb57bffff 89a88cdb5b3ffff        48.0 #> 4: 89a88cdb57bffff 89a88cdb5cfffff        47.0 #> 5: 89a88cdb57bffff 89a88cd909bffff        64.0 #> 6: 89a88cdb57bffff 89a88cd90b7ffff        59.0 land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\")) head(land_use_data) #>                 id population  jobs schools income_per_capita income_decile #>             <char>      <int> <int>   <int>             <num>        <fctr> #> 1: 89a881a5a2bffff        381   180       0           22369.1            10 #> 2: 89a881a5a2fffff        269   134       0            3205.1             9 #> 3: 89a881a5a67ffff        929   143       0           11394.0            10 #> 4: 89a881a5a6bffff        249    61       0            3659.8             9 #> 5: 89a881a5a6fffff        176    11       0            4905.1            10 #> 6: 89a881a5b03ffff        681  1071       0            2200.2             8"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"minimum-travel-cost","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Minimum travel cost","title":"Introduction to accessibility: calculating accessibility measures","text":"cost_to_closest() calculates minimum travel cost given number opportunities. Much like functions ’ll demonstrating section, takes inputs travel matrix land use datasets, name column latter opportunities considered name column former travel cost considered. Additionally, takes minimum number opportunities considered. ’s calculating time origin Belo Horizonte closest school looks like:","code":"mtc <- cost_to_closest(   travel_matrix,   land_use_data,   opportunity = \"schools\",   travel_cost = \"travel_time\",   n = 1 ) head(mtc) #> Key: <id> #>                 id travel_time #>             <char>       <num> #> 1: 89a881a5a2bffff          29 #> 2: 89a881a5a2fffff          24 #> 3: 89a881a5a67ffff          28 #> 4: 89a881a5a6bffff          33 #> 5: 89a881a5a6fffff          32 #> 6: 89a881a5b03ffff          17"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"cutoff-based-cumulative-opportunities","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Cutoff-based cumulative opportunities","title":"Introduction to accessibility: calculating accessibility measures","text":"cumulative_cutoff() calculates traditional cumulative opportunities measure, indicating number opportunities accessible within given travel cost threshold. example, estimate many jobs can reached origin trips taking 30 minutes travel time. Let’s say wanted , instead, calculate passive accessibility - .e. many people destination can reached within given travel cost. requires changes call: just change “opportunity” column \"population\" set active (TRUE default) FALSE. active parameter available accessibility functions well (exception floating_catchment_area()), making easy calculate active passive accessibility.","code":"cum_cutoff <- cumulative_cutoff(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   cutoff = 30 ) head(cum_cutoff) #>                 id  jobs #>             <char> <int> #> 1: 89a881a5a2bffff 14561 #> 2: 89a881a5a2fffff 29452 #> 3: 89a881a5a67ffff 16647 #> 4: 89a881a5a6bffff 10700 #> 5: 89a881a5a6fffff  6669 #> 6: 89a881a5b03ffff 37029 passive_cum_cutoff <- cumulative_cutoff(   travel_matrix,   land_use_data,   opportunity = \"population\",   travel_cost = \"travel_time\",   cutoff = 30,   active = FALSE ) head(passive_cum_cutoff) #>                 id population #>             <char>      <int> #> 1: 89a881a5a2bffff      11053 #> 2: 89a881a5a2fffff      31903 #> 3: 89a881a5a67ffff      12488 #> 4: 89a881a5a6bffff      14474 #> 5: 89a881a5a6fffff      15053 #> 6: 89a881a5b03ffff      69582"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"interval-based-cumulative-opportunities","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Interval-based cumulative opportunities","title":"Introduction to accessibility: calculating accessibility measures","text":"cumulative_time_interval() calculates interval-based cumulative opportunities measure. measure, developed Tomasiello et al. (2023), mitigates impacts arbitrary choices cost cutoffs, one main disadvantages traditional threshold-based cumulative opportunities measure. Given cost interval, calculates several accessibility estimates within interval summarizes using user-specified function. example , calculate average number accessible jobs considering multiple minute--minute time thresholds 40 60 minutes.","code":"cum_interval <- cumulative_interval(   travel_matrix = travel_matrix,   land_use_data = land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   interval = c(40, 60),   summary_function = base::mean ) head(cum_interval) #>                 id   jobs #>             <char>  <int> #> 1: 89a88cdb57bffff 311965 #> 2: 89a88cdb597ffff 249416 #> 3: 89a88cdb5b3ffff 302515 #> 4: 89a88cdb5cfffff 373386 #> 5: 89a88cd909bffff 308429 #> 6: 89a88cd90b7ffff 344118"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"gravity-measures","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Gravity measures","title":"Introduction to accessibility: calculating accessibility measures","text":"gravity() calculates gravity-based measures - .e. measures weight opportunities gradually discounted travel cost increases. course, several different decay functions can used , one range possible different parameters. order accommodate generalization, function takes decay function used parameter. example , calculate accessibility using negative exponential function decay_value (usually referred formulation) 0.2. Please see vignette decay functions information decay functions shipped package use custom functions.","code":"negative_exp <- gravity(   travel_matrix,   land_use_data,   opportunity = \"schools\",   travel_cost = \"travel_time\",   decay_function = decay_exponential(decay_value = 0.2) ) head(negative_exp) #>                 id    schools #>             <char>      <num> #> 1: 89a88cdb57bffff 0.03041853 #> 2: 89a88cdb597ffff 1.15549493 #> 3: 89a88cdb5b3ffff 0.56519126 #> 4: 89a88cdb5cfffff 0.19852152 #> 5: 89a88cd909bffff 0.41378042 #> 6: 89a88cd90b7ffff 0.95737555"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"floating-catchment-area","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Floating catchment area","title":"Introduction to accessibility: calculating accessibility measures","text":"floating_catchment_area() calculates accessibility accounting competition resources using different floating catchment area (FCA) methods. FCA family includes several different methods, can specified using method parameter. time writing vignette, package supports two different methods: 2-Step Floating Catchment Area (\"2sfca\") - first metric FCA family, originally proposed Luo Wang (2003). Balanced Floating Catchment Area (\"bfca\") - takes competition affects account correcting issues inflation demand service levels. Originally proposed Paez, Higgins, Vivona (2019) named Pereira et al. (2021). Please note , since FCA measures consider competition effects, specify column land use dataset represents population competing opportunities demand parameter. function also supports different decay functions. example , calculate accessibility jobs using BFCA method, considering entire population city compete jobs using negative exponential decay function.","code":"bfca <- floating_catchment_area(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\",   method = \"bfca\",   decay_function = decay_exponential(decay_value = 0.5) ) head(bfca) #>                 id       jobs #>             <char>      <num> #> 1: 89a88cdb57bffff 0.10280082 #> 2: 89a88cdb597ffff 0.30930287 #> 3: 89a88cdb5b3ffff 0.07288551 #> 4: 89a88cdb5cfffff 0.09759117 #> 5: 89a88cd909bffff 0.07390234 #> 6: 89a88cd90b7ffff 1.22525579"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"spatial-availability","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Spatial availability","title":"Introduction to accessibility: calculating accessibility measures","text":"spatial_availability() also calculates accessibility considering competition effects, though using spatial availability measure proposed Soukhov et al. (2023). results metric proportional demand origin travel cost takes reach destinations. FCA function, specify column land use dataset contains population competing opportunities can use different decay functions calculate impedance origin-destination pairs.","code":"spatial_avlblt <- spatial_availability(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\",   decay_function = decay_exponential(decay_value = 0.1) ) head(spatial_avlblt) #>                 id     jobs #>             <char>    <num> #> 1: 89a88cdb57bffff 186.0876 #> 2: 89a88cdb597ffff 140.0738 #> 3: 89a88cdb5b3ffff 736.5830 #> 4: 89a88cdb5cfffff 900.9284 #> 5: 89a88cd909bffff   0.0000 #> 6: 89a88cd90b7ffff 204.7962"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"balancing-cost","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Balancing cost","title":"Introduction to accessibility: calculating accessibility measures","text":"balancing_cost() calculates balancing cost accessibility measure. Originally proposed Barboza et al. (2021) name “balancing time”, metric defined travel cost required reach many opportunities number people given origin. Just like previous two functions, balancing_cost() also includes parameter specify population competing opportunities. function also includes cost_increment parameter, used specify increment defines travel cost distribution potential balancing costs picked. example, increment 1 (default) tends suit travel time distributions, meaning function first check origins reach balancing cost travel time 0 minutes, 1 minute, 2 minutes, 3, 4, …, etc. hand, increment 1 might big distribution monetary costs, possibly benefit smaller increment 0.05 (5 cents), example. increment results function looking balancing costs first monetary cost 0, 0.05, 0.10, …, etc. example , use default cost increment 1.","code":"bal_cost <- balancing_cost(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\" ) head(bal_cost) #> Key: <id> #>                 id travel_time #>             <char>       <num> #> 1: 89a881a5a2bffff          15 #> 2: 89a881a5a2fffff          13 #> 3: 89a881a5a67ffff          23 #> 4: 89a881a5a6bffff           7 #> 5: 89a881a5a6fffff          10 #> 6: 89a881a5b03ffff           6"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/accessibility.html","id":"visualize-results","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Visualize results","title":"Introduction to accessibility: calculating accessibility measures","text":"spatial data origins/destinations, can easily merge accessibility create spatial visualizations results. example quickly shows create simple map using ggplot2.","code":"grid <- system.file(\"extdata/grid_bho.rds\", package = \"accessibility\") grid <- readRDS(grid)  spatial_data <- merge(grid, cum_cutoff, by = \"id\")  ggplot() +   geom_sf(data = spatial_data, aes(fill = jobs), color = NA) +   labs(     title = \"Job accessibility by transit in under 30 min.\",     fill = \"Accessible jobs\"   ) +   scale_fill_viridis_c() +   theme_void()"},{"path":[]},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/articles/decay_functions.html","id":"binary","dir":"Articles","previous_headings":"Currently available decay functions","what":"Binary","title":"Decay functions","text":"Also known step decay function, ’s commonly used cumulative opportunities measures. f(tij)={1for tij≤T0for tij>T \\begin{aligned}   f(t_{ij})= \\left\\{       \\begin{array}{ll}           1 & \\quad \\text{}t_{ij} \\leq T \\\\           0 & \\quad \\text{}t_{ij} > T       \\end{array}     \\right.\\\\ \\end{aligned} tijt_{ij} travel cost origin destination j, TT travel cost cutoff.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/articles/decay_functions.html","id":"linear","dir":"Articles","previous_headings":"Currently available decay functions","what":"Linear","title":"Decay functions","text":"Weights decay linearly travel cost cutoff reached. point onward weights assume value 0. f(tij)={(1−tij/T)tij≤T0for tij>T \\begin{aligned}   f(t_{ij})= \\left\\{       \\begin{array}{ll}           (1 - t_{ij}/ T) & \\quad \\text{}t_{ij} \\leq T \\\\           0 & \\quad \\text{}t_{ij} > T       \\end{array}     \\right.\\\\ \\end{aligned} tijt_{ij} travel cost origin destination j, TT travel cost cutoff.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/articles/decay_functions.html","id":"negative-exponential","dir":"Articles","previous_headings":"Currently available decay functions","what":"Negative exponential","title":"Decay functions","text":"f(tij)=e(−βtij) \\begin{aligned}   f(t_{ij})= e^{(-\\beta t_{ij})} \\end{aligned} tijt_{ij} travel cost origin destination j, β\\beta parameter tells speed decay.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/articles/decay_functions.html","id":"inverse-power","dir":"Articles","previous_headings":"Currently available decay functions","what":"Inverse power","title":"Decay functions","text":"f(tij)={1for tij≤1tij−βfor tij>1 \\begin{aligned}   f(t_{ij})= \\left\\{       \\begin{array}{ll}           1 & \\quad \\text{} t_{ij}\\leq 1 \\\\           t_{ij}^{-\\beta} & \\quad \\text{}t_{ij} > 1       \\end{array}     \\right.\\\\ \\end{aligned} tijt_{ij} travel cost origin destination j, β\\beta parameter tells speed decay.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/articles/decay_functions.html","id":"stepped","dir":"Articles","previous_headings":"Currently available decay functions","what":"Stepped","title":"Decay functions","text":"Similar binary function, can take arbitrary number steps. current implementation assumes values changes step, instead right . f(tij)={1for tij<S1v1for tij<S2v2for tij<S3...vn−1for tij<Snvnotherwise \\begin{aligned}   f(t_{ij})= \\left\\{       \\begin{array}{ll}           1 & \\quad \\text{} t_{ij} \\lt S_{1} \\\\           v_{1} & \\quad \\text{} t_{ij} \\lt S_{2} \\\\           v_{2} & \\quad \\text{} t_{ij} \\lt S_{3} \\\\           ... \\\\           v_{n-1} & \\quad \\text{} t_{ij} \\lt S_{n} \\\\           v_{n} & \\quad \\text{otherwise} \\\\       \\end{array}     \\right.\\\\ \\end{aligned} tijt_{ij} travel cost origin destination j, nn total number steps, SkS_{k} travel cost cutoff delimits kthk^{th} step, vkv_{k} value decay function assumes kthk^{th} step.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/articles/decay_functions.html","id":"logistic","dir":"Articles","previous_headings":"Currently available decay functions","what":"Logistic","title":"Decay functions","text":"Weights decay sigmoidally, according reversed cumulative logistic curve. Currently, function implements logistic distribution parameterized cutoff sets inflection point standard deviation sets steepness, according logistic decay curve proposed Bauer Groneberg (2016). Standard deviations values near 0 result weighting curves approximate binary decay, higher values tend linearize curve. f(tij)=1+e−IP×πSD×31+e(tij−IP)×πSD×3 \\begin{aligned}   f(t_{ij}) = \\frac{     1 + e^\\frac{-IP \\times \\pi}{SD \\times \\sqrt{3}}}{     1 + e^\\frac{(t_{ij} - IP) \\times \\pi}{SD \\times \\sqrt{3}}} \\end{aligned} tijt_{ij} travel cost origin destination j, IPIP distribution inflection point, SDSD distribution standard deviation.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/articles/decay_functions.html","id":"quick-demonstration","dir":"Articles","previous_headings":"Currently available decay functions > Logistic","what":"Quick demonstration","title":"Decay functions","text":"decay functions (decay_*()) take decay parameters input return function output. output function, turn, takes vector numeric values input, travel costs, returns list numeric vectors output. Since decay function can take multiple decay parameters input, element output list refers opportunities weights calculated one decay parameters. Let’s check behavior example. code snippet , calculate opportunities weights travel costs, using different negative exponential decay values (0.2 0.3): decay_stepped(), decay function takes one argument (steps weights) names output elements combination steps weights: code , demonstrate decay function travel costs ranging 1 100:","code":"library(accessibility)  output_fn <- decay_exponential(c(0.2, 0.3))  output_fn(c(10, 15, 20)) #> $`0.2` #> [1] 0.13533528 0.04978707 0.01831564 #>  #> $`0.3` #> [1] 0.049787068 0.011108997 0.002478752 stepped_output <- decay_stepped(   steps = list(c(10, 20, 30), c(10, 20, 30, 40)),   weights = list(c(0.67, 0.33, 0), c(0.75, 0.5, 0.25, 0)) )  stepped_output(c(15, 25, 35, 45)) #> $`s(10,20,30);w(0.67,0.33,0)` #> [1] 0.67 0.33 0.00 0.00 #>  #> $`s(10,20,30,40);w(0.75,0.5,0.25,0)` #> [1] 0.75 0.50 0.25 0.00 library(data.table) library(ggplot2)  binary <- decay_binary(cutoff = 50) linear <- decay_linear(cutoff = 50) negative_exp <- decay_exponential(decay_value = 0.2) inverse_power <- decay_power(decay_value = 0.2) stepped <- decay_stepped(steps = c(30, 60, 90), weights = c(0.67, 0.33, 0)) logistic <- decay_logistic(cutoff = 50, sd = 10)  travel_costs <- seq(1, 100, 0.1)  weights <- data.table(   minutes = travel_costs,   binary = as.numeric(binary(travel_costs)[[\"50\"]]),   linear = linear(travel_costs)[[\"50\"]],   negative_exp = negative_exp(travel_costs)[[\"0.2\"]],   inverse_power = inverse_power(travel_costs)[[\"0.2\"]],   stepped = stepped(travel_costs)[[\"s(30,60,90);w(0.67,0.33,0)\"]],   logistic = logistic(travel_costs)[[\"c50;sd10\"]] )  # reshape data to long format weights <- melt(   weights,   id.vars = \"minutes\",   variable.name = \"decay_function\",   value.name = \"weights\" )  ggplot(weights) +   geom_line(     aes(minutes, weights, color = decay_function),     show.legend = FALSE   ) +   facet_wrap(. ~ decay_function, ncol = 2) +   theme_minimal()"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/decay_functions.html","id":"using-a-custom-decay-function","dir":"Articles","previous_headings":"","what":"Using a custom decay function","title":"Decay functions","text":"accessibility also allows use custom decay function, instead one functions shipped package. valid decay function one takes numeric vector travel costs input returns either: numeric vector weights, length input, ; named list numeric vectors used weights, one length input. Let’s check difference case example. Suppose want use simple decay function defines weights multiplicative inverse travel cost - .e. travel_cost−1travel\\_cost^{-1}. just take care case travel cost less 1, case function return values greater 1 replace 1, otherwise implementation pretty simple: Given numeric vector travel costs, function returns numeric vector weights: Using function calculate accessibility easy built-decay functions: Great! now suppose want change function bit. Instead simple multiplicative inverse travel cost, want multiply inverse given decay parameter. Now face “problem”: function need take two inputs (travel cost, , decay parameter multiply travel cost), gravity() can take functions receive single input (travel cost). case, resort strategy used decay functions shipped package, create function takes decay parameter input returns function takes travel cost input output: Great, works! fact, can achieve exact gravity() result shown use my_second_decay(1), instead my_decay: small difference first example passed my_decay (function object) decay_function parameter, whereas second passed function call my_second_decay(1). ’s my_second_decay() (built-decay functions well) actually function “factory”: ’s function returns function. want custom function take many decay parameters inputs, just like built-decay functions? case, output function return list numeric weights named decay parameters set: new custom decay function bit complex previous two, yet much powerful. can use conjunction gravity() (accessibility functions take decay functions input well) calculate accessibility multiple decay parameters single call: create custom decay function, don’t think general cases, just cases matter us. Creating simple function converts one vector another, therefore, might enough, given needs. , however, ’re testing new decay function want check sensitivity different decay parameters, example, might better developing decay function can take many decay values inputs returns list weight vectors output.","code":"my_decay <- function(travel_cost) {   weights <- 1 / travel_cost   weights[weights > 1] <- 1   return(weights) } my_decay(c(0, 0.5, 1, 2, 5, 10)) #> [1] 1.0 1.0 1.0 0.5 0.2 0.1 data_dir <- system.file(\"extdata\", package = \"accessibility\")  travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  custom_gravity <- gravity(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   decay_function = my_decay ) head(custom_gravity) #>                 id     jobs #>             <char>    <num> #> 1: 89a88cdb57bffff 11210.42 #> 2: 89a88cdb597ffff 10775.77 #> 3: 89a88cdb5b3ffff 11480.25 #> 4: 89a88cdb5cfffff 12689.44 #> 5: 89a88cd909bffff 11361.66 #> 6: 89a88cd90b7ffff 12563.65 my_second_decay <- function(decay_parameter) {   function(travel_cost) {     weights <- 1 / (decay_parameter * travel_cost)     weights[weights > 1] <- 1     return(weights)   } }  output_fn <- my_second_decay(2) output_fn(c(0, 0.5, 1, 2, 5, 10)) #> [1] 1.00 1.00 0.50 0.25 0.10 0.05  # compare to the first custom decay function my_decay(c(0, 0.5, 1, 2, 5, 10)) #> [1] 1.0 1.0 1.0 0.5 0.2 0.1 second_custom_gravity <- gravity(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   decay_function = my_second_decay(1) ) head(second_custom_gravity) #>                 id     jobs #>             <char>    <num> #> 1: 89a88cdb57bffff 11210.42 #> 2: 89a88cdb597ffff 10775.77 #> 3: 89a88cdb5b3ffff 11480.25 #> 4: 89a88cdb5cfffff 12689.44 #> 5: 89a88cd909bffff 11361.66 #> 6: 89a88cd90b7ffff 12563.65 decay_power(1) #> function (travel_cost)  #> { #>     weights_list <- lapply(decay_value, function(x) { #>         weights <- travel_cost^(-x) #>         weights[weights > 1] <- 1 #>         weights #>     }) #>     names(weights_list) <- decay_value #>     return(weights_list) #> } #> <bytecode: 0x55d3f37ccad0> #> <environment: 0x55d3f87e75a0> my_third_decay <- function(decay_parameter) {   function(travel_cost) {     weighting_list <- lapply(       decay_parameter,       function(x) {         weights <- 1 / (x * travel_cost)         weights[weights > 1] <- 1         return(weights)       }     )      names(weighting_list) <- decay_parameter     weighting_list   } }  output_fn <- my_third_decay(c(1, 2)) output_fn(c(0, 0.5, 1, 2, 5, 10)) #> $`1` #> [1] 1.0 1.0 1.0 0.5 0.2 0.1 #>  #> $`2` #> [1] 1.00 1.00 0.50 0.25 0.10 0.05  # compare to the first and second custom decay functions  my_decay(c(0, 0.5, 1, 2, 5, 10)) #> [1] 1.0 1.0 1.0 0.5 0.2 0.1  my_second_decay(2)(c(0, 0.5, 1, 2, 5, 10)) #> [1] 1.00 1.00 0.50 0.25 0.10 0.05 third_custom_gravity <- gravity(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   decay_function = my_third_decay(c(1, 2)) ) third_custom_gravity #>                    id decay_function_arg      jobs #>                <char>              <num>     <num> #>    1: 89a88cdb57bffff                  1 11210.421 #>    2: 89a88cdb597ffff                  1 10775.769 #>    3: 89a88cdb5b3ffff                  1 11480.254 #>    4: 89a88cdb5cfffff                  1 12689.441 #>    5: 89a88cd909bffff                  1 11361.664 #>   ---                                              #> 1792: 89a881acda3ffff                  2  5621.512 #> 1793: 89a88cdb543ffff                  2  7406.822 #> 1794: 89a88cda667ffff                  2  5947.782 #> 1795: 89a88cd900fffff                  2  4565.564 #> 1796: 89a881aebafffff                  2     0.000"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/inequality_and_poverty.html","id":"demonstration-on-sample-data","dir":"Articles","previous_headings":"","what":"Demonstration on sample data","title":"Calculating accessibility inequality and poverty","text":"first need calculate accessibility levels going use demonstration. , use cumulative_cutoff() function sample data included package. functions ’ll demonstrating section take much information input, including: accessibility distribution; sociodemographic dataset containing information distribution people study area income; name column accessibility dataset opportunities whose accessibility considered calculation; name column sociodemographic dataset number people cell, used weigh accessibility levels calculating inequality/poverty.","code":"library(accessibility)  data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  access <- cumulative_cutoff(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   cutoff = 30 ) head(access) #>                 id  jobs #>             <char> <int> #> 1: 89a881a5a2bffff 14561 #> 2: 89a881a5a2fffff 29452 #> 3: 89a881a5a67ffff 16647 #> 4: 89a881a5a6bffff 10700 #> 5: 89a881a5a6fffff  6669 #> 6: 89a881a5b03ffff 37029"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/inequality_and_poverty.html","id":"palma-ratio","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Palma Ratio","title":"Calculating accessibility inequality and poverty","text":"palma_ratio() calculates Palma Ratio given accessibility distribution. Originally defined income share wealthiest 10% population divided income share poorest 40%, measure adapted transport planning average accessibility wealthiest 10% divided average accessibility poorest 40%. Palma Ratio values higher 1 indicate scenario wealthiest population higher accessibility levels poorest, whereas values lower 1 indicate opposite situation. function includes additional income parameter, used list column sociodemographic dataset income variable used classify population socioeconomic groups. Please note variable describe income per capita (e.g. mean income per capita, household income per capita, etc), instead total amount income cell.","code":"palma <- palma_ratio(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\",   income = \"income_per_capita\" ) palma #>    palma_ratio #>          <num> #> 1:    3.800465"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/inequality_and_poverty.html","id":"gini-index","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Gini Index","title":"Calculating accessibility inequality and poverty","text":"gini_index() calculates Gini Index given accessibility distribution. Probably frequently used inequality measure transport planning, index estimates much distribution deviates hypothetical situation everyone exact accessibility conditions. Gini Index values range 0 1. value 0 indicates scenario perfect equality, everyone accessibility levels, whereas value 1 indicates scenario perfect inequality, accessibility levels study area concentrated single cell.","code":"gini <- gini_index(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\" ) gini #>    gini_index #>         <num> #> 1:  0.4715251"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/inequality_and_poverty.html","id":"concentration-index","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Concentration Index","title":"Calculating accessibility inequality and poverty","text":"concentration_index() calculates Concentration Index (CI) given accessibility distribution. indicator estimates extent accessibility inequalities systematically associated individuals’ socioeconomic levels. CI values can theoretically vary -1 1 (accessibility concentrated least disadvantaged cell, respectively). Negative values indicate inequalities favor poor, positive values indicate pro-rich bias. Just like palma_ratio(), function includes income parameter indicate variable sociodemographic dataset used rank population least privileged groups. Unlike Palma Ratio function, however, variable can used describe one’s socioeconomic status, education level, example, can passed argument, long can numerically ordered (higher values denote higher socioeconomic status). concentration_index() also includes type parameter, used indicate Concentration Index calculate. parameter currently supports two values, \"standard\" \"corrected\", respectively identify standard relative CI corrected CI, proposed Erreygers (2009).","code":"ci <- concentration_index(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\",   income = \"income_per_capita\",   type = \"corrected\" ) ci #>    concentration_index #>                  <num> #> 1:           0.3346494"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/inequality_and_poverty.html","id":"theil-t","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Theil T","title":"Calculating accessibility inequality and poverty","text":"theil_t() calculates Theil T Index given accessibility distribution. Values range 0 (individuals exactly accessibility levels) natural log n, n number individuals accessibility dataset. individuals can classified mutually exclusive completely exhaustive groups (.e. groups overlap cover entire population), index can decomposed - within-groups inequality component. function includes socioeconomic_groups parameter indicate variable sociodemographic dataset used identify socioeconomic groups used calculate components. Please note output theil_t() varies based value socioeconomic_groups. NULL (default), - within-groups components calculated, function returns data frame containing total aggregate inequality returned area. socioeconomic_groups NULL, however, function returns list containing three dataframes: one summarizing total inequality - within-groups components, one listing contribution group -groups component another listing contribution group within-groups component. behaviors shown .","code":"theil_without_groups <- theil_t(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\" ) theil_without_groups #>      theil_t #>        <num> #> 1: 0.3616631  # some cells are classified as in the decile NA because their income per capita # is NaN, as they don't have any population. we filter these cells from our # accessibility data, otherwise the output would include NA values (note that # subsetting the data like this doesn't affect the assumption that groups are # completely exhaustive, because cells with NA income decile don't have any # population)  na_decile_ids <- land_use_data[is.na(land_use_data$income_decile), ]$id no_na_access <- access[! access$id %in% na_decile_ids, ] sociodem_data <- land_use_data[! land_use_data$id %in% na_decile_ids, ]  theil_with_groups <- theil_t(   no_na_access,   sociodemographic_data = sociodem_data,   opportunity = \"jobs\",   population = \"population\",   socioeconomic_groups = \"income_decile\" ) theil_with_groups #> $summary #>        component     value share_of_total #>           <char>     <num>          <num> #> 1: between_group 0.1280753      0.3541287 #> 2:  within_group 0.2335878      0.6458713 #> 3:         total 0.3616631      1.0000000 #>  #> $within_group_component #>     income_decile       value share_of_component #>            <fctr>       <num>              <num> #>  1:             1 0.009181454         0.03930622 #>  2:             2 0.011413697         0.04886255 #>  3:             3 0.019320622         0.08271246 #>  4:             4 0.023606928         0.10106232 #>  5:             5 0.031470429         0.13472633 #>  6:             6 0.023539337         0.10077296 #>  7:             7 0.033329635         0.14268567 #>  8:             8 0.032585905         0.13950173 #>  9:             9 0.020299031         0.08690107 #> 10:            10 0.028840780         0.12346868 #>  #> $between_group_component #>     income_decile        value #>            <fctr>        <num> #>  1:             1 -0.037573783 #>  2:             2 -0.036276865 #>  3:             3 -0.031829123 #>  4:             4 -0.021600054 #>  5:             5 -0.009938574 #>  6:             6 -0.004401762 #>  7:             7  0.025936879 #>  8:             8  0.042240708 #>  9:             9  0.075742415 #> 10:            10  0.125775443"},{"path":"https://ipeagit.github.io/accessibility/dev/articles/inequality_and_poverty.html","id":"foster-greer-thorbecke-fgt-poverty-measures","dir":"Articles","previous_headings":"Demonstration on sample data","what":"Foster-Greer-Thorbecke (FGT) poverty measures","title":"Calculating accessibility inequality and poverty","text":"fgt_poverty() calculates FGT metrics, family poverty measures originally proposed Foster, Greer, Thorbecke (1984) capture extent severity poverty within accessibility distribution. FGT family composed three measures differ based α\\alpha parameter used calculate (either 0, 1 2) also changes interpretation: α=0\\alpha = 0 (FGT0) measure captures extent poverty simple headcount - .e. proportion people poverty line; α=1\\alpha = 1 (FGT1) measure, also know “poverty gap index”, captures severity poverty average percentage distance poverty line accessibility individuals poverty line; α=2\\alpha = 2 (FGT2) measure simultaneously captures extent severity poverty calculating number people poverty line weighted size accessibility shortfall relative poverty line. function includes additional poverty_line parameter, used define poverty line individuals considered accessibility poverty.","code":"poverty <- fgt_poverty(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\",   poverty_line = 95368 ) poverty #>         FGT0      FGT1      FGT2 #>        <num>     <num>     <num> #> 1: 0.5745378 0.3277383 0.2218769"},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rafael H. M. Pereira. Author. Daniel Herszenhut. Author, maintainer. Anastasia Soukhov. Contributor. Joey Reid. Contributor. Ipea - Institute Applied Economic Research. Copyright holder, funder.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pereira R, Herszenhut D (2026). accessibility: Transport Accessibility Measures. R package version 1.4.0.9000, https://github.com/ipeaGIT/accessibility.","code":"@Manual{,   title = {accessibility: Transport Accessibility Measures},   author = {Rafael H. M. Pereira and Daniel Herszenhut},   year = {2026},   note = {R package version 1.4.0.9000},   url = {https://github.com/ipeaGIT/accessibility}, }"},{"path":"https://ipeagit.github.io/accessibility/dev/index.html","id":"accessibility-","dir":"","previous_headings":"","what":"Transport Accessibility Measures","title":"Transport Accessibility Measures","text":"accessibility offers set fast convenient functions help conducting accessibility analyses. Given pre-computed travel cost matrix land use dataset (containing location jobs, healthcare population, example), package allows one calculate accessibility levels accessibility poverty inequality. package covers majority commonly used accessibility measures (cumulative opportunities, gravity-based floating catchment areas methods), cutting edge measures proposed literature (e.g. balancing cost constrained accessibility), well frequently used inequality poverty metrics (Palma ratio, concentration Theil indices FGT family measures).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Transport Accessibility Measures","text":"Stable version: Development version:","code":"install.packages(\"accessibility\") # install.packages(\"remotes\") remotes::install_github(\"ipeaGIT/accessibility\")"},{"path":"https://ipeagit.github.io/accessibility/dev/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Transport Accessibility Measures","text":"section aims present brief overview packages’ features. Fore details please read vignettes: Introduction accessibility: calculating accessibility measures Decay functions Calculating accessibility inequality poverty calculate accessibility levels, one simply needs pre-calculated travel matrix land use data. showcase available functions: Calculating inequality poverty levels equally easy. use previously calculated cumulative accessibility dataset show available inequality poverty functions:","code":"library(accessibility)  data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  cum_cutoff <- cumulative_cutoff(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   cutoff = 30 ) head(cum_cutoff) #>                 id  jobs #>             <char> <int> #> 1: 89a881a5a2bffff 14561 #> 2: 89a881a5a2fffff 29452 #> 3: 89a881a5a67ffff 16647 #> 4: 89a881a5a6bffff 10700 #> 5: 89a881a5a6fffff  6669 #> 6: 89a881a5b03ffff 37029  grav <- gravity(   travel_matrix,   land_use_data,   opportunity = \"schools\",   travel_cost = \"travel_time\",   decay_function = decay_exponential(decay_value = 0.2) ) head(grav) #>                 id    schools #>             <char>      <num> #> 1: 89a88cdb57bffff 0.03041853 #> 2: 89a88cdb597ffff 1.15549493 #> 3: 89a88cdb5b3ffff 0.56519126 #> 4: 89a88cdb5cfffff 0.19852152 #> 5: 89a88cd909bffff 0.41378042 #> 6: 89a88cd90b7ffff 0.95737555  fca <- floating_catchment_area(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\",   method = \"2sfca\",   decay_function = decay_binary(cutoff = 50) ) head(fca) #>                 id      jobs #>             <char>     <num> #> 1: 89a88cdb57bffff 0.4278111 #> 2: 89a88cdb597ffff 0.3863614 #> 3: 89a88cdb5b3ffff 0.4501725 #> 4: 89a88cdb5cfffff 0.5366707 #> 5: 89a88cd909bffff 0.4280401 #> 6: 89a88cd90b7ffff 0.5176583 palma <- palma_ratio(   cum_cutoff,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\",   income = \"income_per_capita\" ) palma #>    palma_ratio #>          <num> #> 1:    3.800465  poverty <- fgt_poverty(   cum_cutoff,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\",   poverty_line = 95368 ) poverty #>         FGT0      FGT1      FGT2 #>        <num>     <num>     <num> #> 1: 0.5745378 0.3277383 0.2218769"},{"path":"https://ipeagit.github.io/accessibility/dev/index.html","id":"related-work","dir":"","previous_headings":"","what":"Related work:","title":"Transport Accessibility Measures","text":"r5r: Rapid Realistic Routing R5 R tracc: Transport accessibility measures Python access: Spatial Access PySAL aceso: lightweight Python package measuring spatial accessibility","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/index.html","id":"acknowledgement-","dir":"","previous_headings":"","what":"Acknowledgement","title":"Transport Accessibility Measures","text":"accessibility developed team Institute Applied Economic Research (Ipea), Brazil.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/accessibility.html","id":null,"dir":"Reference","previous_headings":"","what":"accessibility: Transport accessibility measures — accessibility","title":"accessibility: Transport accessibility measures — accessibility","text":"set fast convenient functions help conducting accessibility analyses. Given pre-computed travel cost matrix land use dataset (containing example location jobs, healthcare population), package allows one calculate accessibility levels, accessibility poverty inequality. package covers majority commonly used accessibility measures (cumulative opportunities, gravity-based floating catchment areas methods), cutting edge measures proposed literature (e.g. balancing cost constrained accessibility) well frequently used inequality poverty metrics (Palma ratio, concentration Theil indices FGT family measures).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/accessibility.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"accessibility: Transport accessibility measures — accessibility","text":"Please check vignettes package usage: Introduction accessibility: calculating accessibility measures. Run vignette(\"accessibility\") check website. Decay functions. Run vignette(\"decay_functions\", package = \"accessibility\") check website. Calculating accessibility inequality poverty. Run vignette(\"inequality_and_poverty\", package = \"accessibility\") check website.","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/accessibility.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"accessibility: Transport accessibility measures — accessibility","text":"Maintainer: Daniel Herszenhut dhersz@gmail.com (ORCID) Authors: Rafael H. M. Pereira rafa.pereira.br@gmail.com (ORCID) Anastasia Soukhov contributors: Joey Reid [contributor] Ipea - Institute Applied Economic Research [copyright holder, funder]","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/balancing_cost.html","id":null,"dir":"Reference","previous_headings":"","what":"Balancing cost accessibility measure — balancing_cost","title":"Balancing cost accessibility measure — balancing_cost","text":"Calculates balancing cost measure, defined travel cost required reach many opportunities number people given origin. Originally proposed Barboza et al. (2021) , name \"balancing time\". function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/balancing_cost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balancing cost accessibility measure — balancing_cost","text":"","code":"balancing_cost(   travel_matrix,   land_use_data,   opportunity,   travel_cost,   demand,   cost_increment = 1,   group_by = character(0),   fill_missing_ids = TRUE )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/balancing_cost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Balancing cost accessibility measure — balancing_cost","text":"travel_matrix data frame. travel matrix describing costs (.e. travel time, distance, monetary cost, etc.) origins destinations study area. Must contain columns from_id, to_id others specified travel_cost. land_use_data data frame. distribution opportunities within study area cells. Must contain columns id others specified opportunity. opportunity string. name column land_use_data number opportunities/resources/services considered calculating accessibility levels. travel_cost string. name column travel_matrix travel cost origins destinations. notion cost generic kind numeric travel cost, distance, time money. demand string. name column land_use_data number opportunity-demanders origin (e.g., people) considered. cost_increment number. cost increment used defining travel cost distribution potential balancing costs picked. example, increment 1 tends suitable travel time distributions, meaning function first check origins reach balancing cost travel time 0 minutes, 1 minute, 2 minutes, 3, 4, ..., etc. increment 1 might big distribution monetary costs, hand, possibly benefit smaller increment 0.05, example, resulting function looking balancing costs first cost 0, 0.05, 0.10, ..., etc. Defaults 1. group_by character vector. character(0) (default), indicates travel_matrix columns used group accessibility estimates . example, travel_matrix includes departure time column, specifies departure time entry data frame, passing \"departure_time\" parameter results accessibility estimates grouped origin departure time. fill_missing_ids logical. calculating grouped accessibility estimates (.e. by_col NULL), combinations groups origins may missing. example, single trip can depart origin 7:15am reach destination B within 55 minutes, trips departing 7:30am can completed , second combination included output. TRUE (default), function identifies combinations left fills respective accessibility values 0, incurs performance penalty.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/balancing_cost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Balancing cost accessibility measure — balancing_cost","text":"data frame containing accessibility estimates origin/destination (depending active TRUE FALSE) travel matrix. data frame containing accessibility estimates origin travel matrix. Origins marked NA balancing cost never reach many opportunities people residing , given specified travel matrix.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/balancing_cost.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Balancing cost accessibility measure — balancing_cost","text":"Barboza MH, Carneiro MS, Falavigna C, Luz G, Orrico R (2021). “Balancing Time: Using New Accessibility Measure Rio de Janeiro.” Journal Transport Geography, 90, 102924. ISSN 09666923, doi:10.1016/j.jtrangeo.2020.102924 .","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/balancing_cost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balancing cost accessibility measure — balancing_cost","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  bc <- balancing_cost(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\" ) head(bc) #> Key: <id> #>                 id travel_time #>             <char>       <num> #> 1: 89a881a5a2bffff          15 #> 2: 89a881a5a2fffff          13 #> 3: 89a881a5a67ffff          23 #> 4: 89a881a5a6bffff           7 #> 5: 89a881a5a6fffff          10 #> 6: 89a881a5b03ffff           6"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/concentration_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Concentration Index — concentration_index","title":"Concentration Index — concentration_index","text":"Calculates Concentration Index (CI) given accessibility distribution. measures estimates extent accessibility inequalities systematically associated individuals' socioeconomic levels. CI values can theoretically vary -1 +1 (accessibility concentrated least disadvantaged person, respectively). Negative values indicate inequalities favor poor, positive values indicate pro-rich bias. function supports calculating standard relative CI corrected CI, proposed Erreygers (2009) .","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/concentration_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concentration Index — concentration_index","text":"","code":"concentration_index(   accessibility_data,   sociodemographic_data,   opportunity,   population,   income,   type,   group_by = character(0) )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/concentration_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concentration Index — concentration_index","text":"accessibility_data data frame. accessibility levels whose inequality calculated. Must contain columns id others specified opportunity. sociodemographic_data data frame. distribution sociodemographic characteristics population study area cells. Must contain columns id others specified population income. opportunity string. name column accessibility_data accessibility levels considerend calculating inequality levels. population string. name column sociodemographic_data number people cell. Used weigh accessibility levels calculating inequality. income string. name column sociodemographic_data income variable used sort population least privileged. Please note variable describe income per capita (e.g. mean income per capita, household income per capita, etc), instead total amount income cell. Also note , income generally used rank population groups, variable can used describe one's socioeconomic status, education level, can passed argument, long can numerically ordered (higher values denote higher socioeconomic status). type string. type Concentration Index calculate. Current available options \"standard\" \"corrected\". group_by character vector. character(0) (default), indicates accessibility_data columns used group inequality estimates . example, accessibility_data includes scenario column identifies distinct scenarios accessibility estimates refer (e.g. transport policy intervention), passing \"scenario\" parameter results inequality estimates grouped scenario.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/concentration_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Concentration Index — concentration_index","text":"data frame containing inequality estimates study area.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/concentration_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Concentration Index — concentration_index","text":"Erreygers G (2009). “Correcting Concentration Index.” Journal Health Economics, 28(2), 504–515. ISSN 0167-6296, doi:10.1016/j.jhealeco.2008.02.003 .","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/concentration_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Concentration Index — concentration_index","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  access <- cumulative_cutoff(   travel_matrix,   land_use_data,   cutoff = 30,   opportunity = \"jobs\",   travel_cost = \"travel_time\" )  ci <- concentration_index(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\",   income = \"income_per_capita\",   type = \"corrected\" ) ci #>    concentration_index #>                  <num> #> 1:           0.3346494"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":null,"dir":"Reference","previous_headings":"","what":"Constrained accessibility — constrained_accessibility","title":"Constrained accessibility — constrained_accessibility","text":"Calculates accessibility using constraints, proposed Soukhov et al. (2025) . Accessibility conceptualised potential spatial interaction. function covers three constraint cases. Please see Details section information.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constrained accessibility — constrained_accessibility","text":"","code":"constrained_accessibility(   travel_matrix,   land_use_data,   travel_cost,   demand = NULL,   supply = NULL,   constraint,   decay_function,   active = NULL,   error_threshold = 0.001,   improvement_threshold = 1e-06,   max_iterations = 1000,   group_by = character(0),   fill_missing_ids = TRUE,   detailed_results = FALSE )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constrained accessibility — constrained_accessibility","text":"travel_matrix data frame. travel matrix describing costs (.e. travel time, distance, monetary cost, etc.) origins destinations study area. Must contain columns from_id, to_id others specified travel_cost. land_use_data data frame. distribution opportunities within study area cells. Must contain columns id others specified opportunity. travel_cost string. name column travel_matrix travel cost origins destinations. notion cost generic kind numeric travel cost, distance, time money. demand string. name column land_use_data number opportunity-demanders origin (e.g., people) considered. supply string. name column land_use_data number opportunity supply destination (e.g., jobs, school-seats) considered. constraint string. One \"total\", \"singly\", \"doubly\". See Details section information. decay_function fuction converts travel cost impedance factor used weight opportunities. function take numeric vector also return numeric vector output, length input. convenience, package currently includes following functions: decay_binary(), decay_exponential(), decay_power() decay_stepped(). See documentation decay function details. active logical. TRUE, function calculates active accessibility (quantity opportunities can reached given origin). FALSE, calculates passive accessibility (many people destination can reached), equivalent notion market potential. parameter works constraint types \"total\" \"singly\". Ignored constraint = \"doubly\". error_threshold Numeric. Convergence criterion used calibration doubly-constrained case (constraint = \"doubly\"). improvement_threshold Numeric. Convergence criterion improvement used calibration doubly-constrained case (constraint = \"doubly\"). max_iterations Integer. Maximum iterations used calibration doubly-constrained case (constraint = \"doubly\"). group_by character vector. character(0) (default), indicates travel_matrix columns used group accessibility estimates . example, travel_matrix includes departure time column, specifies departure time entry data frame, passing \"departure_time\" parameter results accessibility estimates grouped origin departure time. fill_missing_ids logical. calculating grouped accessibility estimates (.e. by_col NULL), combinations groups origins may missing. example, single trip can depart origin 7:15am reach destination B within 55 minutes, trips departing 7:30am can completed , second combination included output. TRUE (default), function identifies combinations left fills respective accessibility values 0, incurs performance penalty. detailed_results Logical. Whether return detailed OD-level results.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constrained accessibility — constrained_accessibility","text":"function covers family constrained accessibility measures proposed Soukhov et al. (2025) .","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"total-constrained-accessibility","dir":"Reference","previous_headings":"","what":"Total Constrained Accessibility","title":"Constrained accessibility — constrained_accessibility","text":"Allocates system-wide total proportionally based travel impedance origins destinations. measure uses logic total ~('unconstrained' Wilson's terms)~ constraint. Use measure total quantity supply demand system known representing accessibility proportion total meaningful.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"requirement-","dir":"Reference","previous_headings":"","what":"Requirement:","title":"Constrained accessibility — constrained_accessibility","text":"Either demand supply must provided (provide ).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"interpretation-","dir":"Reference","previous_headings":"","what":"Interpretation:","title":"Constrained accessibility — constrained_accessibility","text":"active = TRUE (active accessibility): Results represent total number  opportunities (supply) accessible origin based region-relative travel impedance. units 'supply' (e.g., jobs, school seats). detailed_results = FALSE, outputs aggregated returned origin. detailed_results = TRUE, OD-level flows returned. Summing flows origin equals aggregated result. active = FALSE (passive accessibility, notion market potential): Results represent total number population (demand) can reach destination based region-relative travel impedance. units 'demand' (e.g., population). detailed_results = FALSE, outputs aggregated destination. detailed_results = TRUE, OD-level flows returned. Summing flows destination equals aggregated result.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"use-cases-","dir":"Reference","previous_headings":"","what":"Use cases:","title":"Constrained accessibility — constrained_accessibility","text":"Active accessibility (aggregated): \"many jobs can reached origin zone given region-relative travel impedance?\" Active accessibility (flow-level): \"many jobs can reached flow ->1 given ->1's region-relative travel impedance?\" Passive accessibility (aggregated): \"many people can reach destination zone 1 given region-relative travel impedance?\" Passive accessibility (flow-level): \"many people reached flow 1->given 1->'s region-relative travel impedance?\"","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"singly-constrained-accessibility","dir":"Reference","previous_headings":"","what":"Singly Constrained Accessibility","title":"Constrained accessibility — constrained_accessibility","text":"Allocates opportunities destination (population origin) proportionally based travel impedance opposite marginal. measure uses logic single constraint Wilson (1971) . Use measure modeling competition, demand supply conceptualised influence accessibility one side fixed. measure distributes flows totals match constrained side weighting travel impedance unconstrained side.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"requirements-","dir":"Reference","previous_headings":"","what":"Requirements:","title":"Constrained accessibility — constrained_accessibility","text":"demand supply must provided (logical active determines either demand supply constrained).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"interpretation--1","dir":"Reference","previous_headings":"","what":"Interpretation:","title":"Constrained accessibility — constrained_accessibility","text":"active = TRUE (active accessibility): constrains supply. Results represent total number opportunities (supply) accessible origin based region-relative travel impedance population origin. units 'supply' (e.g., jobs, school seats). detailed_results = FALSE, outputs aggregated returned origin. detailed_results = TRUE, OD-level flows returned. Summing flows origin equals aggregated result. active = FALSE (passive accessibility, notion market potential): constrains demand. Results represent total number population (demand) can reach destination based region-relative travel impedance opportunities destination. units 'demand' (e.g., population). detailed_results = FALSE, outputs aggregated destination. detailed_results = TRUE, OD-level flows returned. Summing flows destination equals aggregated result.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"use-cases--1","dir":"Reference","previous_headings":"","what":"Use cases:","title":"Constrained accessibility — constrained_accessibility","text":"Active accessibility (aggregated): \"many jobs can reached origin zone given region-relative travel impedance demand?\" Active accessibility (flow-level): \"many jobs can reached flow ->1 given ->1's region-relative travel impedance demand?\" Passive accessibility (aggregated): \"many people can reach destination zone 1 given region-relative travel impedance supply?\" Passive accessibility (flow-level): \"many people reached flow 1->given 1->'s region-relative travel impedance supply?\" NOTE: active form measure yields equivalent results spatial_availability() function, different logic.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"doubly-constrained-accessibility","dir":"Reference","previous_headings":"","what":"Doubly Constrained Accessibility","title":"Constrained accessibility — constrained_accessibility","text":"Allocates flows supply destination matches demand origin. uses Wilson's doubly-constrained gravity model Wilson (1971) . model uses iterative proportional fitting update balancing factors order calibrate OD flows margins (A_i origins B_j destinations) convergence (.e. sum demand supply match). guarantees flows satisfy marginals weighted travel  impedance.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"requirements--1","dir":"Reference","previous_headings":"","what":"Requirements:","title":"Constrained accessibility — constrained_accessibility","text":"demand supply must provided. Unlike total singly, doubly requires sum demand supply match; otherwise, model converge. active must NULL. Since supply must match demand, units distinction 'active' 'passive' notions. acceptsdetailed_results = TRUE.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"interpretation--2","dir":"Reference","previous_headings":"","what":"Interpretation:","title":"Constrained accessibility — constrained_accessibility","text":"Results include OD-level flows (flow) along balancing factors (A_i, B_j) travel impedance weights. resulting flows represent distribution demand supply across origin-destination pairs. NOTE: OD flows flow units (jointly determined demand supply).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"use-cases--2","dir":"Reference","previous_headings":"","what":"Use cases:","title":"Constrained accessibility — constrained_accessibility","text":"flow-level: \"count ->1 flows given ->1's region-relative travel impedance, demand supply?\"","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Constrained accessibility — constrained_accessibility","text":"Soukhov , Pereira RH, Higgins CD, Páez (2025). “family accessibility measures derived spatial interaction principles.” PLoS One, 20(11), e0335951. Wilson AG (1971). “family spatial interaction models, associated developments.” Environment Planning , 3(1), 1–32.","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/constrained_accessibility.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constrained accessibility — constrained_accessibility","text":"","code":"# Load demo data shipped with the package data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  # Total-constrained (active accessibility, aggregated): returns units of # accessible supply by origin (requires supply) constrained_accessibility(   travel_matrix   = travel_matrix,   land_use_data   = land_use_data,   travel_cost     = \"travel_time\",   constraint      = \"total\",   decay_function  = decay_exponential(0.1),   demand          = NULL,   supply          = \"jobs\",   active          = TRUE,   detailed_results = FALSE ) #>              from_id   supply #>               <char>    <num> #>   1: 89a88cdb57bffff 263.8175 #>   2: 89a88cdb597ffff 264.7306 #>   3: 89a88cdb5b3ffff 319.5332 #>   4: 89a88cdb5cfffff 428.2523 #>   5: 89a88cd909bffff 291.7166 #>  ---                          #> 894: 89a881acda3ffff 280.1091 #> 895: 89a88cdb543ffff 697.2299 #> 896: 89a88cda667ffff 346.8143 #> 897: 89a88cd900fffff 113.1569 #> 898: 89a881aebafffff   0.0000  # Total-constrained (passive accessibility, aggregated): returns units of # accessible demand by destination  (requires demand) constrained_accessibility(   travel_matrix  = travel_matrix,   land_use_data  = land_use_data,   travel_cost    = \"travel_time\",   constraint     = \"total\",   decay_function = decay_exponential(0.1),   demand         = \"population\",   supply         = NULL,   active         = FALSE,   detailed_results = FALSE ) #>                to_id       demand #>               <char>        <num> #>   1: 89a88cdb57bffff  720.1584302 #>   2: 89a88cdb597ffff  958.7228358 #>   3: 89a88cdb5b3ffff 1074.8576863 #>   4: 89a88cdb5cfffff  632.9250575 #>   5: 89a88cd909bffff  882.5883640 #>  ---                              #> 894: 89a881ae92fffff   13.4118931 #> 895: 89a881ae923ffff    0.2403741 #> 896: 89a881ae9afffff    3.6023628 #> 897: 89a88cd8407ffff   27.6942661 #> 898: 89a881aebafffff    0.0000000  # Singly-constrained (active accessibility, aggregated): returns units of # accessible supply by origin (requires supply and demand) constrained_accessibility(   travel_matrix   = travel_matrix,   land_use_data   = land_use_data,   travel_cost     = \"travel_time\",   constraint      = \"singly\",   decay_function  = decay_exponential(0.1),   demand          = \"population\",   supply          = \"jobs\",   active          = TRUE,   detailed_results = FALSE ) #>              from_id    supply #>               <char>     <num> #>   1: 89a88cdb57bffff  186.0876 #>   2: 89a88cdb597ffff  140.0738 #>   3: 89a88cdb5b3ffff  736.5830 #>   4: 89a88cdb5cfffff  900.9284 #>   5: 89a88cd909bffff    0.0000 #>  ---                           #> 894: 89a881acda3ffff  453.8818 #> 895: 89a88cdb543ffff 1184.0239 #> 896: 89a88cda667ffff  276.2530 #> 897: 89a88cd900fffff  103.5370 #> 898: 89a881aebafffff    0.0000  # Doubly-constrained: returns units of flow (requires both demand and supply # (totals that match) and `detailed_results = TRUE`)  # Using a small toy dataset with matching totals. tm_small <- data.table::data.table(   expand.grid(from_id = c(\"1\",\"2\",\"3\"), to_id = c(\"1\",\"2\",\"3\")) ) tm_small[, travel_time := c(10, 30, 15, 30, 10, 25, 15, 25, 10)] #>    from_id  to_id travel_time #>     <fctr> <fctr>       <num> #> 1:       1      1          10 #> 2:       2      1          30 #> 3:       3      1          15 #> 4:       1      2          30 #> 5:       2      2          10 #> 6:       3      2          25 #> 7:       1      3          15 #> 8:       2      3          25 #> 9:       3      3          10 lu_small <- data.table::data.table(   id         = c(\"1\",\"2\",\"3\"),   population = c(4, 10, 6),   # sum = 20   jobs       = c(7,  5,  8)   # sum = 20 )  constrained_accessibility(   travel_matrix   = tm_small,   land_use_data   = lu_small,   travel_cost     = \"travel_time\",   constraint      = \"doubly\",   decay_function  = decay_exponential(0.1),   demand          = \"population\",   supply          = \"jobs\",   detailed_results = TRUE ) #>    from_id  to_id       flow       A_i      B_j kappa_doubly        error #>     <fctr> <fctr>      <num>     <num>    <num>        <num>        <num> #> 1:       1      1 2.52693730 0.1721781 1.424797   0.36099104 0.0007282441 #> 2:       1      2 0.09995405 0.1721781 0.583010   0.01999081 0.0007282441 #> 3:       1      3 1.37651660 0.1721781 1.119684   0.17206457 0.0007282441 #> 4:       2      1 2.15341665 0.4336710 1.424797   0.30763095 0.0007282441 #> 5:       2      2 4.65063122 0.4336710 0.583010   0.93012624 0.0007282441 #> 6:       2      3 3.18866969 0.4336710 1.119684   0.39858371 0.0007282441 #> 7:       3      1 2.31964604 0.1737245 1.424797   0.33137801 0.0007282441 #> 8:       3      2 0.24941474 0.1737245 0.583010   0.04988295 0.0007282441 #> 9:       3      3 3.43481370 0.1737245 1.119684   0.42935171 0.0007282441"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cost_to_closest.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimum travel cost to closest N number of opportunities — cost_to_closest","title":"Minimum travel cost to closest N number of opportunities — cost_to_closest","text":"Calculates minimum travel cost closest N number opportunities. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cost_to_closest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimum travel cost to closest N number of opportunities — cost_to_closest","text":"","code":"cost_to_closest(   travel_matrix,   land_use_data,   opportunity,   travel_cost,   n = 1,   group_by = character(0),   active = TRUE,   fill_missing_ids = TRUE )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cost_to_closest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimum travel cost to closest N number of opportunities — cost_to_closest","text":"travel_matrix data frame. travel matrix describing costs (.e. travel time, distance, monetary cost, etc.) origins destinations study area. Must contain columns from_id, to_id others specified travel_cost. land_use_data data frame. distribution opportunities within study area cells. Must contain columns id others specified opportunity. opportunity string. name column land_use_data number opportunities/resources/services considered calculating accessibility levels. travel_cost string. name column travel_matrix travel cost origins destinations. notion cost generic kind numeric travel cost, distance, time money. n numeric vector. minimum number opportunities considered. Defaults 1. one value provided, output includes extra column specifying number opportunities minimum travel cost refers . group_by character vector. character(0) (default), indicates travel_matrix columns used group accessibility estimates . example, travel_matrix includes departure time column, specifies departure time entry data frame, passing \"departure_time\" parameter results accessibility estimates grouped origin departure time. active logical. TRUE, function calculates active accessibility (quantity opportunities can reached given origin). FALSE, calculates passive accessibility (many people destination can reached), equivalent notion market potential. fill_missing_ids logical. Calculating minimum travel cost closest N number opportunities may result missing ids output reach specified amount opportunities across destinations can reach. example, estimating minimum travel time origin can reach 4 opportunities takes reach 5 opportunities resulting origin included output. TRUE (default), function identifies ids left output fill respective minimum travel costs Inf, incurs performance penalty.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cost_to_closest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimum travel cost to closest N number of opportunities — cost_to_closest","text":"data frame containing accessibility estimates origin/destination (depending active TRUE FALSE) travel matrix.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cost_to_closest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimum travel cost to closest N number of opportunities — cost_to_closest","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  df <- cost_to_closest(   travel_matrix,   land_use_data,   n = 1,   opportunity = \"schools\",   travel_cost = \"travel_time\" ) head(df) #> Key: <id> #>                 id travel_time #>             <char>       <num> #> 1: 89a881a5a2bffff          29 #> 2: 89a881a5a2fffff          24 #> 3: 89a881a5a67ffff          28 #> 4: 89a881a5a6bffff          33 #> 5: 89a881a5a6fffff          32 #> 6: 89a881a5b03ffff          17  df <- cost_to_closest(   travel_matrix,   land_use_data,   n = c(1, 2),   opportunity = \"schools\",   travel_cost = \"travel_time\" ) head(df) #> Key: <id, n> #>                 id     n travel_time #>             <char> <num>       <num> #> 1: 89a881a5a2bffff     1          29 #> 2: 89a881a5a2bffff     2          32 #> 3: 89a881a5a2fffff     1          24 #> 4: 89a881a5a2fffff     2          25 #> 5: 89a881a5a67ffff     1          28 #> 6: 89a881a5a67ffff     2          31"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_cutoff.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative access based on a travel cost cutoff — cumulative_cutoff","title":"Cumulative access based on a travel cost cutoff — cumulative_cutoff","text":"Calculates number opportunities accessible given specified travel cost cutoff. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_cutoff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative access based on a travel cost cutoff — cumulative_cutoff","text":"","code":"cumulative_cutoff(   travel_matrix,   land_use_data,   opportunity,   travel_cost,   cutoff,   group_by = character(0),   active = TRUE,   fill_missing_ids = TRUE )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_cutoff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative access based on a travel cost cutoff — cumulative_cutoff","text":"travel_matrix data frame. travel matrix describing costs (.e. travel time, distance, monetary cost, etc.) origins destinations study area. Must contain columns from_id, to_id others specified travel_cost. land_use_data data frame. distribution opportunities within study area cells. Must contain columns id others specified opportunity. opportunity string. name column land_use_data number opportunities/resources/services considered calculating accessibility levels. travel_cost character vector. name columns travel_matrix travel costs origins destinations considered calculation. cutoff Either numeric vector list numeric vectors, one cost specified travel_cost. travel cost cutoffs consider calculating accessibility levels. list, function finds every single possible cutoff combination use calculate accessibility (e.g. one specifies travel time cutoffs 30 60 minutes monetary cost cutoffs 5 10 dollars, output includes accessibility estimates limited 30 min & 5 dollars, 30 min & 10 dollars, 60 min & 5 dollars 60 min & 10 dollars). cases, cost constraints considered simultaneously - .e. trips take 30 minutes less 5 dollars less completed, example, included accessibility output. cutoff parameter included final output input includes single cutoff single travel cost. group_by character vector. character(0) (default), indicates travel_matrix columns used group accessibility estimates . example, travel_matrix includes departure time column, specifies departure time entry data frame, passing \"departure_time\" parameter results accessibility estimates grouped origin departure time. active logical. TRUE, function calculates active accessibility (quantity opportunities can reached given origin). FALSE, calculates passive accessibility (many people destination can reached), equivalent notion market potential. fill_missing_ids logical. Calculating cumulative accessibility may result missing ids reach destinations within specified travel cost cutoff. example, using travel time cutoff 20 minutes, estimating accessibility origin can reach destinations 40 minutes results id included output. TRUE (default), function identifies origins left fills respective accessibility values 0, incurs performance penalty.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_cutoff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative access based on a travel cost cutoff — cumulative_cutoff","text":"data frame containing accessibility estimates origin/destination (depending active TRUE FALSE) travel matrix.","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_cutoff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative access based on a travel cost cutoff — cumulative_cutoff","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  # active accessibility: number of schools accessible from each origin df <- cumulative_cutoff(   travel_matrix = travel_matrix,   land_use_data = land_use_data,   cutoff = 30,   opportunity = \"schools\",   travel_cost = \"travel_time\" ) head(df) #>                 id schools #>             <char>   <int> #> 1: 89a881a5a2bffff       1 #> 2: 89a881a5a2fffff      10 #> 3: 89a881a5a67ffff       1 #> 4: 89a881a5a6bffff       0 #> 5: 89a881a5a6fffff       0 #> 6: 89a881a5b03ffff      14  df <- cumulative_cutoff(   travel_matrix = travel_matrix,   land_use_data = land_use_data,   cutoff = c(30, 60),   opportunity = \"schools\",   travel_cost = \"travel_time\" ) head(df) #>                 id travel_time schools #>             <char>       <num>   <int> #> 1: 89a881a5a2bffff          30       1 #> 2: 89a881a5a2bffff          60      76 #> 3: 89a881a5a2fffff          30      10 #> 4: 89a881a5a2fffff          60      91 #> 5: 89a881a5a67ffff          30       1 #> 6: 89a881a5a67ffff          60      82  # passive accessibility: number of people that can reach each destination df <- cumulative_cutoff(   travel_matrix = travel_matrix,   land_use_data = land_use_data,   cutoff = 30,   opportunity = \"population\",   travel_cost = \"travel_time\",   active = FALSE ) head(df) #>                 id population #>             <char>      <int> #> 1: 89a881a5a2bffff      11053 #> 2: 89a881a5a2fffff      31903 #> 3: 89a881a5a67ffff      12488 #> 4: 89a881a5a6bffff      14474 #> 5: 89a881a5a6fffff      15053 #> 6: 89a881a5b03ffff      69582  # using multiple travel costs pareto_frontier <- readRDS(file.path(data_dir, \"pareto_frontier.rds\"))  df <- cumulative_cutoff(   pareto_frontier,   land_use_data = land_use_data,   opportunity = \"jobs\",   travel_cost = c(\"travel_time\", \"monetary_cost\"),   cutoff = list(c(20, 30), c(0, 5, 10)) ) head(df) #>                 id travel_time monetary_cost  jobs #>             <char>       <num>         <num> <int> #> 1: 89a881a5a2bffff          20             0   397 #> 2: 89a881a5a2bffff          20             5   397 #> 3: 89a881a5a2bffff          20            10   397 #> 4: 89a881a5a2bffff          30             0   846 #> 5: 89a881a5a2bffff          30             5 20923 #> 6: 89a881a5a2bffff          30            10 20923"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative access based on maximum travel time interval — cumulative_interval","title":"Cumulative access based on maximum travel time interval — cumulative_interval","text":"Calculates average median number opportunities can reached considering multiple maximum travel cost thresholds within given travel cost interval specified user. time interval cumulative accessibility measures originally proposed Tomasiello et al. (2023) . function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative access based on maximum travel time interval — cumulative_interval","text":"","code":"cumulative_interval(   travel_matrix,   land_use_data,   opportunity,   travel_cost,   interval,   interval_increment = 1,   summary_function = stats::median,   group_by = character(0),   active = TRUE )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative access based on maximum travel time interval — cumulative_interval","text":"travel_matrix data frame. travel matrix describing costs (.e. travel time, distance, monetary cost, etc.) origins destinations study area. Must contain columns from_id, to_id others specified travel_cost. land_use_data data frame. distribution opportunities within study area cells. Must contain columns id others specified opportunity. opportunity string. name column land_use_data number opportunities/resources/services considered calculating accessibility levels. travel_cost string. name column travel_matrix travel cost origins destinations. notion cost generic kind numeric travel cost, distance, time money. interval numeric vector length 2. Indicates start end points interval travel cost thresholds used. first entry must lower second. interval_increment numeric. many travel cost units separate cutoffs used calculate accessibility estimates used calculate summary estimate within specified interval. thought resolution distribution travel costs within interval. Defaults 1. summary_function function. function used summarize distribution accessibility estimates within travel cost interval single value. Can function takes arbitrary number numeric values input returns single number output. Defaults stats::median(). group_by character vector. character(0) (default), indicates travel_matrix columns used group accessibility estimates . example, travel_matrix includes departure time column, specifies departure time entry data frame, passing \"departure_time\" parameter results accessibility estimates grouped origin departure time. active logical. TRUE, function calculates active accessibility (quantity opportunities can reached given origin). FALSE, calculates passive accessibility (many people destination can reached), equivalent notion market potential.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_interval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative access based on maximum travel time interval — cumulative_interval","text":"data frame containing accessibility estimates origin/destination (depending active TRUE FALSE) travel matrix.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_interval.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative access based on maximum travel time interval — cumulative_interval","text":"Tomasiello DB, Herszenhut D, Oliveira JLA, Braga CKV, Pereira RHM (2023). “Time Interval Metric Cumulative Opportunity Accessibility.” Applied Geography, 157, 103007. ISSN 0143-6228, doi:10.1016/j.apgeog.2023.103007 .","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/cumulative_interval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative access based on maximum travel time interval — cumulative_interval","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  df <- cumulative_interval(   travel_matrix = travel_matrix,   land_use_data = land_use_data,   interval = c(20, 30),   opportunity = \"schools\",   travel_cost = \"travel_time\" ) head(df) #>                 id schools #>             <char>   <int> #> 1: 89a88cdb57bffff       0 #> 2: 89a88cdb597ffff      14 #> 3: 89a88cdb5b3ffff      17 #> 4: 89a88cdb5cfffff       4 #> 5: 89a88cd909bffff       6 #> 6: 89a88cd90b7ffff      12  df <- cumulative_interval(   travel_matrix = travel_matrix,   land_use_data = land_use_data,   interval = c(40, 80),   opportunity = \"jobs\",   travel_cost = \"travel_time\" ) head(df) #>                 id   jobs #>             <char>  <int> #> 1: 89a88cdb57bffff 435782 #> 2: 89a88cdb597ffff 409191 #> 3: 89a88cdb5b3ffff 423974 #> 4: 89a88cdb5cfffff 460740 #> 5: 89a88cd909bffff 437645 #> 6: 89a88cd90b7ffff 449585"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_binary.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary (a.k.a. step) decay function — decay_binary","title":"Binary (a.k.a. step) decay function — decay_binary","text":"Returns binary weighting function (frequently used calculate cumulative opportunities measures) used inside accessibility calculating functions. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_binary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary (a.k.a. step) decay function — decay_binary","text":"","code":"decay_binary(cutoff)"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_binary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binary (a.k.a. step) decay function — decay_binary","text":"cutoff numeric vector. numbers indicating travel cost cutoffs.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_binary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binary (a.k.a. step) decay function — decay_binary","text":"function takes generic travel cost vector (numeric) input returns list weight vectors (list numeric vectors, named arguments passed decay function).","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_binary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binary (a.k.a. step) decay function — decay_binary","text":"","code":"weighting_function <- decay_binary(cutoff = 30)  weighting_function(c(20, 35)) #> $`30` #> [1] 1 0 #>   weighting_function <- decay_binary(cutoff = c(30, 45))  weighting_function(c(20, 35)) #> $`30` #> [1] 1 0 #>  #> $`45` #> [1] 1 1 #>"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_exponential.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative exponential decay function — decay_exponential","title":"Negative exponential decay function — decay_exponential","text":"Returns negative exponential weighting function used inside accessibility calculating functions. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_exponential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative exponential decay function — decay_exponential","text":"","code":"decay_exponential(decay_value)"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_exponential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative exponential decay function — decay_exponential","text":"decay_value numeric vector. calibration parameters , multiplied travel cost, used exponent e negative exponential function.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_exponential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative exponential decay function — decay_exponential","text":"function takes generic travel cost vector (numeric) input returns list weight vectors (list numeric vectors, named arguments passed decay function).","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_exponential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative exponential decay function — decay_exponential","text":"","code":"weighting_function <- decay_exponential(decay_value = 0.1)  weighting_function(c(20, 30)) #> $`0.1` #> [1] 0.13533528 0.04978707 #>   weighting_function <- decay_exponential(decay_value = c(0.1, 0.2))  weighting_function(c(20, 30)) #> $`0.1` #> [1] 0.13533528 0.04978707 #>  #> $`0.2` #> [1] 0.018315639 0.002478752 #>"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear decay function — decay_linear","title":"Linear decay function — decay_linear","text":"Returns linear weighting function used inside accessibility calculating functions. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear decay function — decay_linear","text":"","code":"decay_linear(cutoff)"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear decay function — decay_linear","text":"cutoff numeric vector. Indicates travel cost cutoffs weighting factor decays linearly. point onward weight equal 0.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear decay function — decay_linear","text":"function takes generic travel cost vector (numeric) input returns list weight vectors (list numeric vectors, named arguments passed decay function).","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear decay function — decay_linear","text":"","code":"weighting_function <- decay_linear(cutoff = 30)  weighting_function(c(20, 35)) #> $`30` #> [1] 0.3333333 0.0000000 #>   weighting_function <- decay_linear(cutoff = c(30, 45))  weighting_function(c(20, 35)) #> $`30` #> [1] 0.3333333 0.0000000 #>  #> $`45` #> [1] 0.5555556 0.2222222 #>"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_logistic.html","id":null,"dir":"Reference","previous_headings":"","what":"Logistic decay function — decay_logistic","title":"Logistic decay function — decay_logistic","text":"Returns logistic weighting function (weights follow distribution reversed cumulative logistic curve) used inside accessibility calculating functions. logistic curve parameterized cutoff sets inflection point standard deviation sets steepness. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_logistic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logistic decay function — decay_logistic","text":"","code":"decay_logistic(cutoff, sd)"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_logistic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logistic decay function — decay_logistic","text":"cutoff numeric vector. cost value serves inflection point cumulative logistic curve. sd numeric vector length cutoff. standard deviation logistic curve. Values near 0 result weighting curves approximate binary decay, higher values tend linearize decay.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_logistic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logistic decay function — decay_logistic","text":"function takes generic travel cost vector (numeric) input returns vector weights (numeric).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_logistic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Logistic decay function — decay_logistic","text":"using function created decay_logistic(), output named combination cutoffs (\"c\") standard deviations (\"sd\") - e.g. given cutoffs c(30, 40) standard deviations c(10, 20), first element output named \"c30;sd10\" second named \"c40;sd20\". function uses adjusted logistic decay curve proposed Bauer Groneberg (2016) , condition f(0) = 1 met (.e. weight opportunity whose cost reach 0 1).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_logistic.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Logistic decay function — decay_logistic","text":"Bauer J, Groneberg DA (2016). “Measuring Spatial Accessibility Health Care Providers – Introduction Variable Distance Decay Function within Floating Catchment Area (FCA) Method.” PLOS ONE, 11(7), e0159148. ISSN 1932-6203, doi:10.1371/journal.pone.0159148 .","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_logistic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logistic decay function — decay_logistic","text":"","code":"weighting_function <- decay_logistic(cutoff = 30, sd = 5)  weighting_function(c(0, 30, 45, 60)) #> $`c30;sd5` #> [1] 1.000000e+00 5.000094e-01 4.314804e-03 1.877853e-05 #>   weighting_function <- decay_logistic(cutoff = c(30, 45), sd = c(5, 10))  weighting_function(c(0, 30, 45, 60)) #> $`c30;sd5` #> [1] 1.000000e+00 5.000094e-01 4.314804e-03 1.877853e-05 #>  #> $`c45;sd10` #> [1] 1.00000000 0.93850470 0.50014263 0.06178056 #>"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse power decay function — decay_power","title":"Inverse power decay function — decay_power","text":"Returns inverse power weighting function used inside accessibility calculating functions. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse power decay function — decay_power","text":"","code":"decay_power(decay_value)"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse power decay function — decay_power","text":"decay_value numeric vector. calibration parameters used exponents inverse power function.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverse power decay function — decay_power","text":"function takes generic travel cost vector (numeric) input returns list weight vectors (list numeric vectors, named arguments passed decay function).","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inverse power decay function — decay_power","text":"","code":"weighting_function <- decay_power(decay_value = 0.1)  weighting_function(c(20, 35)) #> $`0.1` #> [1] 0.7411344 0.7007986 #>   weighting_function <- decay_power(decay_value = c(0.1, 0.2))  weighting_function(c(20, 35)) #> $`0.1` #> [1] 0.7411344 0.7007986 #>  #> $`0.2` #> [1] 0.5492803 0.4911186 #>"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_stepped.html","id":null,"dir":"Reference","previous_headings":"","what":"Stepped decay function — decay_stepped","title":"Stepped decay function — decay_stepped","text":"Returns stepped weighting function used inside accessibility calculating functions. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_stepped.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stepped decay function — decay_stepped","text":"","code":"decay_stepped(steps, weights)"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_stepped.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stepped decay function — decay_stepped","text":"steps numeric vector list numeric vectors. travel cost steps, ascending order. Please include travel cost 0 step: already handled function. weights numeric vector length steps list numeric vectors whose lengths equal lengths elements index steps. values, 0 1, function assumes step. Please include weight 1 first value: already handled function. function considers steps' intervals \"open right\", meaning function assumes step value actual step, right . Please see illustrative examples effects assumption results.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_stepped.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stepped decay function — decay_stepped","text":"function takes generic travel cost vector (numeric) input returns vector weights (numeric).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_stepped.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stepped decay function — decay_stepped","text":"steps weights parameters given lists, content matched element-wise define stepped weighting function .e. first element steps matched first element weights, second element steps matched second weights, etc. using function created decay_stepped(), output named combination steps (\"s\") weights (\"w\") e.g. given steps c(10, 20, 30) weights c(0.66, 0.33, 0), output named \"s(10,20,30);w(0.66,0.33,0)\".","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/decay_stepped.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stepped decay function — decay_stepped","text":"","code":"weighting_function <- decay_stepped(   c(10, 20, 30, 40),   weights = c(0.75, 0.5, 0.25, 0) )  weighting_function(c(5, 25, 35, 45)) #> $`s(10,20,30,40);w(0.75,0.5,0.25,0)` #> [1] 1.00 0.50 0.25 0.00 #>   weighting_function <- decay_stepped(   list(c(10, 20, 30, 40), c(10, 20, 30, 40)),   weights = list(c(0.75, 0.5, 0.25, 0), c(0.8, 0.6, 0.4, 0.2)) )  weighting_function(c(5, 25, 35, 45)) #> $`s(10,20,30,40);w(0.75,0.5,0.25,0)` #> [1] 1.00 0.50 0.25 0.00 #>  #> $`s(10,20,30,40);w(0.8,0.6,0.4,0.2)` #> [1] 1.0 0.6 0.4 0.2 #>   # intervals are open on the right, so the values change exactly at each step weighting_function(c(0, 10, 20, 30, 40)) #> $`s(10,20,30,40);w(0.75,0.5,0.25,0)` #> [1] 1.00 0.75 0.50 0.25 0.00 #>  #> $`s(10,20,30,40);w(0.8,0.6,0.4,0.2)` #> [1] 1.0 0.8 0.6 0.4 0.2 #>"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/doubly_constrained.html","id":null,"dir":"Reference","previous_headings":"","what":"Doubly constrained accessibility — doubly_constrained","title":"Doubly constrained accessibility — doubly_constrained","text":"Calculates accessibility using Wilson's doubly-constrained gravity model. measure allocates flows origins destinations origin totals equal demand destination totals equal supply. Note: internal helper function used constrained_accessibility() constraint = \"doubly\".","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/doubly_constrained.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Doubly constrained accessibility — doubly_constrained","text":"data.table/data.frame either OD-level flows (detailed_results = TRUE) marginals; see Details.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/doubly_constrained.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Doubly constrained accessibility — doubly_constrained","text":"","code":"NULL #> NULL"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/fgt_poverty.html","id":null,"dir":"Reference","previous_headings":"","what":"Foster-Greer-Thorbecke (FGT) poverty measures — fgt_poverty","title":"Foster-Greer-Thorbecke (FGT) poverty measures — fgt_poverty","text":"Calculates FGT metrics, family poverty measures originally proposed Foster et al. (1984)  capture extent severity poverty within accessibility distribution. FGT family composed three measures differ based \\(\\alpha\\) parameter used calculate (either 0, 1 2) also changes interpretation. Please see details section information interpretation measures.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/fgt_poverty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Foster-Greer-Thorbecke (FGT) poverty measures — fgt_poverty","text":"","code":"fgt_poverty(   accessibility_data,   sociodemographic_data,   opportunity,   population,   poverty_line,   group_by = character(0) )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/fgt_poverty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Foster-Greer-Thorbecke (FGT) poverty measures — fgt_poverty","text":"accessibility_data data frame. accessibility levels whose poverty levels calculated. Must contain columns id others specified opportunity. sociodemographic_data data frame. distribution sociodemographic characteristics population study area cells. Must contain columns id others specified population. opportunity string. name column accessibility_data accessibility levels considerend calculating accessibility poverty. population string. name column sociodemographic_data number people cell. Used weigh accessibility levels calculating poverty. poverty_line numeric. poverty line individuals considered accessibility poverty. group_by character vector. character(0) (default), indicates accessibility_data columns used group poverty estimates . example, accessibility_data includes race column specifies racial category population (e.g. \"black\" \"white\") entry refers , passing \"race\" parameter results poverty estimates grouped race.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/fgt_poverty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Foster-Greer-Thorbecke (FGT) poverty measures — fgt_poverty","text":"data frame containing three poverty estimates (FGT0, FGT1 FGT2) study area.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/fgt_poverty.html","id":"interpretation-of-fgt-measures","dir":"Reference","previous_headings":"","what":"Interpretation of FGT measures","title":"Foster-Greer-Thorbecke (FGT) poverty measures — fgt_poverty","text":"interpretation FGT measure depends \\(\\alpha\\) parameter used calculate : \\(\\alpha = 0\\) (FGT0) measure captures extent poverty simple headcount - .e. proportion people poverty line; \\(\\alpha = 1\\) (FGT1) measure, also know \"poverty gap index\", captures severity poverty average percentage distance poverty line accessibility individuals poverty line; \\(\\alpha = 2\\) (FGT2) measure simultaneously captures extent severity poverty calculating number people poverty line weighted size accessibility shortfall relative poverty line. FGT values range 0 1. value 0 indicates every individual poverty line. every individual poverty line, however, FGT0 value 1 FGT1 FGT2 values approach 1.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/fgt_poverty.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Foster-Greer-Thorbecke (FGT) poverty measures — fgt_poverty","text":"Foster J, Greer J, Thorbecke E (1984). “Class Decomposable Poverty Measures.” Econometrica, 52(3), 761–766. ISSN 0012-9682, doi:10.2307/1913475 , 1913475.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/fgt_poverty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Foster-Greer-Thorbecke (FGT) poverty measures — fgt_poverty","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  access <- cumulative_cutoff(   travel_matrix,   land_use_data,   cutoff = 30,   opportunity = \"jobs\",   travel_cost = \"travel_time\" )  poverty <- fgt_poverty(   access,   opportunity = \"jobs\",   sociodemographic_data = land_use_data,   population = \"population\",   poverty_line = 95368 ) poverty #>         FGT0      FGT1      FGT2 #>        <num>     <num>     <num> #> 1: 0.5745378 0.3277383 0.2218769"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/floating_catchment_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Floating catchment area accessibility — floating_catchment_area","title":"Floating catchment area accessibility — floating_catchment_area","text":"Calculates accessibility accounting competition resources using measure floating catchment area (FCA) family. Please see details available FCA measures. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/floating_catchment_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Floating catchment area accessibility — floating_catchment_area","text":"","code":"floating_catchment_area(   travel_matrix,   land_use_data,   opportunity,   travel_cost,   demand,   method,   decay_function,   group_by = character(0),   fill_missing_ids = TRUE )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/floating_catchment_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Floating catchment area accessibility — floating_catchment_area","text":"travel_matrix data frame. travel matrix describing costs (.e. travel time, distance, monetary cost, etc.) origins destinations study area. Must contain columns from_id, to_id others specified travel_cost. land_use_data data frame. distribution opportunities within study area cells. Must contain columns id others specified opportunity. opportunity string. name column land_use_data number opportunities/resources/services considered calculating accessibility levels. travel_cost string. name column travel_matrix travel cost origins destinations. notion cost generic kind numeric travel cost, distance, time money. demand string. name column land_use_data number opportunity-demanders origin (e.g., people) considered. method string. floating catchment area measure use. Current available options \"2sfca\" \"bfca\". info details. decay_function fuction converts travel cost impedance factor used weight opportunities. function take numeric vector also return numeric vector output, length input. convenience, package currently includes following functions: decay_binary(), decay_exponential(), decay_power() decay_stepped(). See documentation decay function details. group_by character vector. character(0) (default), indicates travel_matrix columns used group accessibility estimates . example, travel_matrix includes departure time column, specifies departure time entry data frame, passing \"departure_time\" parameter results accessibility estimates grouped origin departure time. fill_missing_ids logical. calculating grouped accessibility estimates (.e. by_col NULL), combinations groups origins may missing. example, single trip can depart origin 7:15am reach destination B within 55 minutes, trips departing 7:30am can completed , second combination included output. TRUE (default), function identifies combinations left fills respective accessibility values 0, incurs performance penalty.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/floating_catchment_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Floating catchment area accessibility — floating_catchment_area","text":"data frame containing accessibility estimates origin/destination (depending active TRUE FALSE) travel matrix.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/floating_catchment_area.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Floating catchment area accessibility — floating_catchment_area","text":"package currently includes two built-FCA measures: 2SFCA - 2-Step Floating Catchment Area measure first accessibility metric FCA family. originally proposed Luo Wang (2003) . BFCA - Balanced Floating Catchment Area measure calculates accessibility accounting competition effects simultaneously correcting issues inflation demand service levels present FCA measures. originally proposed Paez et al. (2019)  named Pereira et al. (2021) .","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/floating_catchment_area.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Floating catchment area accessibility — floating_catchment_area","text":"Luo W, Wang F (2003). “Measures Spatial Accessibility Health Care GIS Environment: Synthesis Case Study Chicago Region.” Environment Planning B: Planning Design, 30(6), 865–884. ISSN 0265-8135, 1472-3417, doi:10.1068/b29120 . Paez , Higgins CD, Vivona SF (2019). “Demand Level Service Inflation Floating Catchment Area (FCA) Methods.” PLOS ONE, 14(6), e0218773. ISSN 1932-6203, doi:10.1371/journal.pone.0218773 . Pereira RHM, Braga CKV, Servo LM, Serra B, Amaral P, Gouveia N, Paez (2021). “Geographic Access COVID-19 Healthcare Brazil Using Balanced Float Catchment Area Approach.” Social Science & Medicine, 273, 113773. ISSN 0277-9536, doi:10.1016/j.socscimed.2021.113773 .","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/floating_catchment_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Floating catchment area accessibility — floating_catchment_area","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  # 2SFCA with a step decay function df <- floating_catchment_area(   travel_matrix,   land_use_data,   method = \"2sfca\",   decay_function = decay_binary(cutoff = 50),   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\" ) head(df) #>                 id      jobs #>             <char>     <num> #> 1: 89a88cdb57bffff 0.4278111 #> 2: 89a88cdb597ffff 0.3863614 #> 3: 89a88cdb5b3ffff 0.4501725 #> 4: 89a88cdb5cfffff 0.5366707 #> 5: 89a88cd909bffff 0.4280401 #> 6: 89a88cd90b7ffff 0.5176583   # BFCA with an exponential decay function df <- floating_catchment_area(   travel_matrix,   land_use_data,   method = \"bfca\",   decay_function = decay_exponential(decay_value = 0.5),   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\" ) head(df) #>                 id       jobs #>             <char>      <num> #> 1: 89a88cdb57bffff 0.10280082 #> 2: 89a88cdb597ffff 0.30930287 #> 3: 89a88cdb5b3ffff 0.07288551 #> 4: 89a88cdb5cfffff 0.09759117 #> 5: 89a88cd909bffff 0.07390234 #> 6: 89a88cd90b7ffff 1.22525579"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gini_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Gini Index — gini_index","title":"Gini Index — gini_index","text":"Calculates Gini Index given accessibility distribution.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gini_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gini Index — gini_index","text":"","code":"gini_index(   accessibility_data,   sociodemographic_data,   opportunity,   population,   group_by = character(0) )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gini_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gini Index — gini_index","text":"accessibility_data data frame. accessibility levels whose inequality calculated. Must contain columns id others specified opportunity. sociodemographic_data data frame. distribution sociodemographic characteristics population study area cells. Must contain columns id others specified population. opportunity string. name column accessibility_data accessibility levels considerend calculating inequality levels. population string. name column sociodemographic_data number people cell. Used weigh accessibility levels calculating inequality. group_by character vector. character(0) (default), indicates accessibility_data columns used group inequality estimates . example, accessibility_data includes scenario column identifies distinct scenarios accessibility estimates refer (e.g. transport policy intervention), passing \"scenario\" parameter results inequality estimates grouped scenario.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gini_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gini Index — gini_index","text":"data frame containing inequality estimates study area.","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gini_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gini Index — gini_index","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  access <- cumulative_cutoff(   travel_matrix,   land_use_data,   cutoff = 30,   opportunity = \"jobs\",   travel_cost = \"travel_time\" )  gini <- gini_index(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\" ) gini #>    gini_index #>         <num> #> 1:  0.4715251"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gravity.html","id":null,"dir":"Reference","previous_headings":"","what":"Gravity-based accessibility measures — gravity","title":"Gravity-based accessibility measures — gravity","text":"Calculates gravity-based accessibility using decay function specified user. function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gravity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gravity-based accessibility measures — gravity","text":"","code":"gravity(   travel_matrix,   land_use_data,   opportunity,   travel_cost,   decay_function,   group_by = character(0),   active = TRUE,   fill_missing_ids = TRUE )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gravity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gravity-based accessibility measures — gravity","text":"travel_matrix data frame. travel matrix describing costs (.e. travel time, distance, monetary cost, etc.) origins destinations study area. Must contain columns from_id, to_id others specified travel_cost. land_use_data data frame. distribution opportunities within study area cells. Must contain columns id others specified opportunity. opportunity string. name column land_use_data number opportunities/resources/services considered calculating accessibility levels. travel_cost string. name column travel_matrix travel cost origins destinations. notion cost generic kind numeric travel cost, distance, time money. decay_function fuction converts travel cost impedance factor used weight opportunities. function take numeric vector also return numeric vector output, length input. convenience, package currently includes following functions: decay_binary(), decay_exponential(), decay_power() decay_stepped(). See documentation decay function details. group_by character vector. character(0) (default), indicates travel_matrix columns used group accessibility estimates . example, travel_matrix includes departure time column, specifies departure time entry data frame, passing \"departure_time\" parameter results accessibility estimates grouped origin departure time. active logical. TRUE, function calculates active accessibility (quantity opportunities can reached given origin). FALSE, calculates passive accessibility (many people destination can reached), equivalent notion market potential. fill_missing_ids logical. calculating grouped accessibility estimates (.e. by_col NULL), combinations groups origins may missing. example, single trip can depart origin 7:15am reach destination B within 55 minutes, trips departing 7:30am can completed , second combination included output. TRUE (default), function identifies combinations left fills respective accessibility values 0, incurs performance penalty.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gravity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gravity-based accessibility measures — gravity","text":"data frame containing accessibility estimates origin/destination (depending active TRUE FALSE) travel matrix.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/gravity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gravity-based accessibility measures — gravity","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  df_linear <- gravity(   travel_matrix,   land_use_data,   decay_function = decay_linear(cutoff = 50),   opportunity = \"schools\",   travel_cost = \"travel_time\" ) head(df_linear) #>                 id schools #>             <char>   <num> #> 1: 89a88cdb57bffff   9.260 #> 2: 89a88cdb597ffff  18.748 #> 3: 89a88cdb5b3ffff  20.900 #> 4: 89a88cdb5cfffff  13.660 #> 5: 89a88cd909bffff  18.980 #> 6: 89a88cd90b7ffff  24.780  df_exp <- gravity(   travel_matrix,   land_use_data,   decay_function = decay_exponential(decay_value = 0.5),   opportunity = \"schools\",   travel_cost = \"travel_time\" ) head(df_exp) #>                 id      schools #>             <char>        <num> #> 1: 89a88cdb57bffff 2.705781e-06 #> 2: 89a88cdb597ffff 1.249277e-01 #> 3: 89a88cdb5b3ffff 8.269861e-03 #> 4: 89a88cdb5cfffff 3.023943e-03 #> 5: 89a88cd909bffff 3.059679e-02 #> 6: 89a88cd90b7ffff 8.581966e-02"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/palma_ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Palma Ratio — palma_ratio","title":"Palma Ratio — palma_ratio","text":"Calculates Palma Ratio given accessibility distribution. Originally defined income share richest 10% population divided income share poorest 40%, measure adapted transport planning average accessibility richest 10% divided average accessibility poorest 40%.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/palma_ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Palma Ratio — palma_ratio","text":"","code":"palma_ratio(   accessibility_data,   sociodemographic_data,   opportunity,   population,   income,   group_by = character(0) )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/palma_ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Palma Ratio — palma_ratio","text":"accessibility_data data frame. accessibility levels whose inequality calculated. Must contain columns id others specified opportunity. sociodemographic_data data frame. distribution sociodemographic characteristics population study area cells. Must contain columns id others specified population income. opportunity string. name column accessibility_data accessibility levels considerend calculating inequality levels. population string. name column sociodemographic_data number people cell. Used weigh accessibility levels calculating inequality. income string. name column sociodemographic_data income variable used classify population socioeconomic groups. Please note variable describe income per capita (e.g. mean income per capita, household income per capita, etc), instead total amount income cell. group_by character vector. character(0) (default), indicates accessibility_data columns used group inequality estimates . example, accessibility_data includes scenario column identifies distinct scenarios accessibility estimates refer (e.g. transport policy intervention), passing \"scenario\" parameter results inequality estimates grouped scenario.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/palma_ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Palma Ratio — palma_ratio","text":"data frame containing inequality estimates study area.","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/palma_ratio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Palma Ratio — palma_ratio","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  access <- cumulative_cutoff(   travel_matrix,   land_use_data,   cutoff = 30,   opportunity = \"jobs\",   travel_cost = \"travel_time\" )  palma <- palma_ratio(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\",   income = \"income_per_capita\" ) palma #>    palma_ratio #>          <num> #> 1:    3.800465"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/singly_constrained.html","id":null,"dir":"Reference","previous_headings":"","what":"Singly constrained accessibility — singly_constrained","title":"Singly constrained accessibility — singly_constrained","text":"Allocates opportunities destination proportionally based travel impedance population origin. Uses logic Wilson's single constraint. Returns values unit 'demand'. Internal helper function used constrained_accessibility() constraint = \"singly\".","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/singly_constrained.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Singly constrained accessibility — singly_constrained","text":"data.table/data.frame results (structure mirrors wrapper).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/singly_constrained.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Singly constrained accessibility — singly_constrained","text":"","code":"NULL #> NULL"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/spatial_availability.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial availability — spatial_availability","title":"Spatial availability — spatial_availability","text":"Calculates spatial availability, accessibility measured proposed Soukhov et al. (2023)  takes account competition effects. accessibility levels result using measure proportional demand origin travel cost takes reach destinations. spatial availability particular case constrained_accessibility(constraint = \"singly\"). function generic kind numeric travel cost, distance, time money.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/spatial_availability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial availability — spatial_availability","text":"","code":"spatial_availability(   travel_matrix,   land_use_data,   opportunity,   travel_cost,   demand,   decay_function,   alpha = 1,   group_by = character(0),   fill_missing_ids = TRUE,   detailed_results = FALSE )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/spatial_availability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial availability — spatial_availability","text":"travel_matrix data frame. travel matrix describing costs (.e. travel time, distance, monetary cost, etc.) origins destinations study area. Must contain columns from_id, to_id others specified travel_cost. land_use_data data frame. distribution opportunities within study area cells. Must contain columns id others specified opportunity. opportunity string. name column land_use_data number opportunities/resources/services considered calculating accessibility levels. travel_cost string. name column travel_matrix travel cost origins destinations. notion cost generic kind numeric travel cost, distance, time money. demand string. name column land_use_data number opportunity-demanders origin (e.g., people) considered. decay_function fuction converts travel cost impedance factor used weight opportunities. function take numeric vector also return numeric vector output, length input. convenience, package currently includes following functions: decay_binary(), decay_exponential(), decay_power() decay_stepped(). See documentation decay function details. alpha numeric. parameter used modulate effect demand population. less 1, opportunities allocated rapidly smaller centers relative larger ones; values higher 1 achieve opposite effect. group_by character vector. character(0) (default), indicates travel_matrix columns used group accessibility estimates . example, travel_matrix includes departure time column, specifies departure time entry data frame, passing \"departure_time\" parameter results accessibility estimates grouped origin departure time. fill_missing_ids logical. calculating grouped accessibility estimates (.e. by_col NULL), combinations groups origins may missing. example, single trip can depart origin 7:15am reach destination B within 55 minutes, trips departing 7:30am can completed , second combination included output. TRUE (default), function identifies combinations left fills respective accessibility values 0, incurs performance penalty. detailed_results logical. Whether return spatial availability results aggregated origin-destination pair (TRUE) origin (FALSE, default). TRUE, output also includes demand, impedance combined balancing factors used calculate spatial availability. Please note argument fill_missing_ids affect output detailed_results TRUE.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/spatial_availability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial availability — spatial_availability","text":"data frame containing accessibility estimates origin/destination (depending active TRUE FALSE) travel matrix.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/spatial_availability.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial availability — spatial_availability","text":"Soukhov , Páez , Higgins CD, Mohamed M (2023). “Introducing Spatial Availability, Singly-Constrained Measure Competitive Accessibility.” PLOS ONE, 18(1), e0278468. ISSN 1932-6203, doi:10.1371/journal.pone.0278468 .","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/spatial_availability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial availability — spatial_availability","text":"","code":"# the example below is based on Soukhov et al. (2023) paper  travel_matrix <- data.table::data.table(   from_id = rep(c(\"A\", \"B\", \"C\"), each = 3),   to_id = as.character(rep(1:3, 3)),   travel_time = c(15, 30, 100, 30, 15, 100, 100, 100, 15) ) land_use_data <- data.table::data.table(   id = c(\"A\", \"B\", \"C\", \"1\", \"2\", \"3\"),   population = c(50000, 150000, 10000, 0, 0, 0),   jobs = c(0, 0, 0, 100000, 100000, 10000) )  df <- spatial_availability(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\",   decay_function = decay_exponential(decay_value = 0.1) ) df #>        id       jobs #>    <char>      <num> #> 1:      A  66833.466 #> 2:      B 133203.363 #> 3:      C   9963.171  detailed_df <- spatial_availability(   travel_matrix,   land_use_data,   opportunity = \"jobs\",   travel_cost = \"travel_time\",   demand = \"population\",   decay_function = decay_exponential(decay_value = 0.1),   detailed_results = TRUE ) detailed_df #>    from_id  to_id demand_bal_fac impedance_bal_fac combined_bal_fac #>     <char> <char>          <num>             <num>            <num> #> 1:       A      1     0.23809524      0.8174384949     5.990064e-01 #> 2:       A      2     0.23809524      0.1823951823     6.922691e-02 #> 3:       A      3     0.23809524      0.0002033856     1.013219e-03 #> 4:       B      1     0.71428571      0.1823951823     4.009692e-01 #> 5:       B      2     0.71428571      0.8174384949     9.307605e-01 #> 6:       B      3     0.71428571      0.0002033856     3.039656e-03 #> 7:       C      1     0.04761905      0.0001663229     2.437577e-05 #> 8:       C      2     0.04761905      0.0001663229     1.262535e-05 #> 9:       C      3     0.04761905      0.9995932288     9.959471e-01 #>            jobs #>           <num> #> 1: 59900.642536 #> 2:  6922.691048 #> 3:    10.132187 #> 4: 40096.919886 #> 5: 93076.046417 #> 6:    30.396561 #> 7:     2.437577 #> 8:     1.262535 #> 9:  9959.471253"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/theil_t.html","id":null,"dir":"Reference","previous_headings":"","what":"Theil T Index — theil_t","title":"Theil T Index — theil_t","text":"Calculates Theil T Index given accessibility distribution. Values range 0 (individuals exactly accessibility levels) natural log n, n number individuals accessibility dataset. individuals can classified mutually exclusive completely exhaustive groups, index can decomposed -groups inequaliy component within-groups component.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/theil_t.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Theil T Index — theil_t","text":"","code":"theil_t(   accessibility_data,   sociodemographic_data,   opportunity,   population,   socioeconomic_groups = NULL,   group_by = character(0) )"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/theil_t.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Theil T Index — theil_t","text":"accessibility_data data frame. accessibility levels whose inequality calculated. Must contain columns id others specified opportunity. sociodemographic_data data frame. distribution sociodemographic characteristics population study area cells. Must contain columns id others specified population socioeconomic_groups. opportunity string. name column accessibility_data accessibility levels considerend calculating inequality levels. population string. name column sociodemographic_data number people cell. Used weigh accessibility levels calculating inequality. socioeconomic_groups string. name column sociodemographic_data whose values identify socioeconomic groups used calculate - within-groups inequality levels. NULL (default), - within-groups components calculated total aggregate inequality returned. group_by character vector. character(0) (default), indicates accessibility_data columns used group inequality estimates . example, accessibility_data includes scenario column identifies distinct scenarios accessibility estimates refer (e.g. transport policy intervention), passing \"scenario\" parameter results inequality estimates grouped scenario.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/theil_t.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Theil T Index — theil_t","text":"socioeconomic_groups NULL, data frame containing total Theil T estimates study area. , list containing three dataframes: one summarizing total inequality - within-groups components, one listing contribution group -groups component another listing contribution group within-groups component.","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/reference/theil_t.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Theil T Index — theil_t","text":"","code":"data_dir <- system.file(\"extdata\", package = \"accessibility\") travel_matrix <- readRDS(file.path(data_dir, \"travel_matrix.rds\")) land_use_data <- readRDS(file.path(data_dir, \"land_use_data.rds\"))  access <- cumulative_cutoff(   travel_matrix,   land_use_data,   cutoff = 30,   opportunity = \"jobs\",   travel_cost = \"travel_time\" )  ti <- theil_t(   access,   sociodemographic_data = land_use_data,   opportunity = \"jobs\",   population = \"population\" ) ti #>      theil_t #>        <num> #> 1: 0.3616631  # to calculate inequality between and within income deciles, we pass # \"income_decile\" to socioeconomic_groups. # some cells, however, are classified as in the decile NA because their # income per capita is NaN, as they don't have any population. we filter # these cells from our accessibility data, otherwise the output would include # NA values (note that subsetting the data like this doesn't affect the # assumption that groups are completely exhaustive, because cells with NA # income decile don't have any population)  na_decile_ids <- land_use_data[is.na(land_use_data$income_decile), ]$id access <- access[! access$id %in% na_decile_ids, ] sociodem_data <- land_use_data[! land_use_data$id %in% na_decile_ids, ]  ti <- theil_t(   access,   sociodemographic_data = sociodem_data,   opportunity = \"jobs\",   population = \"population\",   socioeconomic_groups = \"income_decile\" ) ti #> $summary #>        component     value share_of_total #>           <char>     <num>          <num> #> 1: between_group 0.1280753      0.3541287 #> 2:  within_group 0.2335878      0.6458713 #> 3:         total 0.3616631      1.0000000 #>  #> $within_group_component #>     income_decile       value share_of_component #>            <fctr>       <num>              <num> #>  1:             1 0.009181454         0.03930622 #>  2:             2 0.011413697         0.04886255 #>  3:             3 0.019320622         0.08271246 #>  4:             4 0.023606928         0.10106232 #>  5:             5 0.031470429         0.13472633 #>  6:             6 0.023539337         0.10077296 #>  7:             7 0.033329635         0.14268567 #>  8:             8 0.032585905         0.13950173 #>  9:             9 0.020299031         0.08690107 #> 10:            10 0.028840780         0.12346868 #>  #> $between_group_component #>     income_decile        value #>            <fctr>        <num> #>  1:             1 -0.037573783 #>  2:             2 -0.036276865 #>  3:             3 -0.031829123 #>  4:             4 -0.021600054 #>  5:             5 -0.009938574 #>  6:             6 -0.004401762 #>  7:             7  0.025936879 #>  8:             8  0.042240708 #>  9:             9  0.075742415 #> 10:            10  0.125775443 #>"},{"path":"https://ipeagit.github.io/accessibility/dev/reference/total_constrained.html","id":null,"dir":"Reference","previous_headings":"","what":"Total constrained accessibility — total_constrained","title":"Total constrained accessibility — total_constrained","text":"Allocates total opportunities region proportionally based travel impedance. Uses logic total (unconstrained Wilson's terms) constraint. Returns values units 'supply' (.e., opportunities) active = TRUE returns values units demand' (.e., population) active = FALSE.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/total_constrained.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Total constrained accessibility — total_constrained","text":"data.table/data.frame results (structure mirrors wrapper).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/total_constrained.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Total constrained accessibility — total_constrained","text":"Internal helper used constrained_accessibility() constraint = \"total\".","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/reference/total_constrained.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Total constrained accessibility — total_constrained","text":"","code":"NULL #> NULL"},{"path":[]},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"new-features-1-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"accessibility 1.5.0","text":"New function constrained_accessibility().","code":""},{"path":[]},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"accessibility-140","dir":"Changelog","previous_headings":"","what":"accessibility 1.4.0","title":"accessibility 1.4.0","text":"CRAN release: 2024-03-06","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"bug-fixes-1-4-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"accessibility 1.4.0","text":"Fixed bug land use data passed accessibility functions tibble lead error.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"new-features-1-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"accessibility 1.4.0","text":"New function decay_logistic().","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"notes-1-4-0","dir":"Changelog","previous_headings":"","what":"Notes","title":"accessibility 1.4.0","text":"Package description adjusted better reflect current set available features.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"accessibility-130","dir":"Changelog","previous_headings":"","what":"accessibility 1.3.0","title":"accessibility 1.3.0","text":"CRAN release: 2023-10-20","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"new-features-1-3-0","dir":"Changelog","previous_headings":"","what":"New features","title":"accessibility 1.3.0","text":"New parameter detailed_results spatial_availability(), used specify whether results aggregated origin-destination pair origin. aggregation origin-destination pair, output also includes demand, impedance combined balancing factors used calculate spatial availability.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"accessibility-120","dir":"Changelog","previous_headings":"","what":"accessibility 1.2.0","title":"accessibility 1.2.0","text":"CRAN release: 2023-09-21","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"new-features-1-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"accessibility 1.2.0","text":"New inequality functions concentration_index() theil_t().","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"notes-1-2-0","dir":"Changelog","previous_headings":"","what":"Notes","title":"accessibility 1.2.0","text":"Various documentation tweaks. Testing performance greatly improved.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"accessibility-110","dir":"Changelog","previous_headings":"","what":"accessibility 1.1.0","title":"accessibility 1.1.0","text":"CRAN release: 2023-06-22","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"new-features-1-1-0","dir":"Changelog","previous_headings":"","what":"New features","title":"accessibility 1.1.0","text":"package now includes functions estimate accessibility inequalities (palma_ratio() gini_index()) poverty (fgt_poverty()). New accessibility functions spatial_availability() balancing_cost(). New vignette “Calculating accessibility inequality poverty”. cost_to_closest() parameter n now accepts numeric vector, instead restricted single number. cumulative_cutoff() parameters cutoff travel_cost now accepts numeric character vector, respectively, instead restricted single number/string. cumulative_interval() parameter interval now accepts list numeric vectors, instead restricted single vector. decay functions can now take numeric vectors input, instead restricted single number (case decay_stepped(), steps weights can take list numeric vectors input, instead restricted single numeric vector ).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"notes-1-1-0","dir":"Changelog","previous_headings":"","what":"Notes","title":"accessibility 1.1.0","text":"Various documentation tweaks. Added new accessibility functions intro vignette.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"accessibility-101","dir":"Changelog","previous_headings":"","what":"accessibility 1.0.1","title":"accessibility 1.0.1","text":"CRAN release: 2022-10-06","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"bug-fixes-1-0-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"accessibility 1.0.1","text":"Fixed bug cost_to_closest() return NA values filling missing ids (filled Inf, since reach opportunities). also responsible warning reported #27, also fixed.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"accessibility-100","dir":"Changelog","previous_headings":"","what":"accessibility 1.0.0","title":"accessibility 1.0.0","text":"CRAN release: 2022-07-22 package tremendous changes. Basically, ’s single part remained untouched: documentation, vignettes, function names, parameter names, extra functionality, performance improvements, etc. impossible highlight everything done, ’ll try summary key points following topics.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"breaking-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"accessibility 1.0.0","text":"Accessibility functions previously worked single input dataset: data. Now require two input datasets: travel_matrix land_use_data. time_to_closest() -> cost_to_closest() cumulative_time_cutoff() -> cumulative_cutoff() cumulative_time_interval() -> cumulative_interval() gravity_access() -> gravity() opportunity_col -> opportunity travel_cost_col -> travel_cost by_col -> active cost_to_closest(): n_opportunities -> n cumulative_interval(): stat -> summary_function floating_catchment_area(): population_col -> demand floating_catchment_area(): fca_metric -> method active now takes logical, instead string (by_col previously took). cumulative_interval(): summary_function now takes function, instead string (stat previously took).","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"New features","title":"accessibility 1.0.0","text":"New function decay_stepped(). New parameter interval_increment cumulative_interval(), used specify many travel cost units separate cutoffs used calculate accessibility estimates used calculate summary estimate within specified interval. accessibility functions gained group_by parameter, allows accessibility estimates grouped one columns present travel_matrix. accessibility functions (cumulative_interval()) gained fill_missing_ids parameter, includes results origins whose accessibility 0 , due commonly overlooked implementation details, usually left output. cumulative_interval() doesn’t parameter result always include origins, otherwise summary measure wouldn’t calculated properly.","code":""},{"path":"https://ipeagit.github.io/accessibility/dev/news/index.html","id":"accessibility-010","dir":"Changelog","previous_headings":"","what":"accessibility 0.1.0","title":"accessibility 0.1.0","text":"CRAN release: 2022-06-30 Initial CRAN release.","code":""}]
